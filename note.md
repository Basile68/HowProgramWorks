# CPU

## 热身问答

1. 程序是指示计算机每一步行动的一组指令；
2. 程序是由指令和数据构成的；
3. 机器语言是 CPU 可以直接识别并使用的语言；
     - 使用 C、Java 等语言编写的程序最后都会转化成机器语言。
4. 正在运行的程序存储在内存；
     - 硬盘和磁盘等媒介上保存的程序被复制到内存后才能运行。
5. 内存地址是内存中用来表示命令和数据存储位置的数值；
     - 地址是由整数值表示。
        - 计算机的内存（RAM）是由许多存储单元组成的，每个存储单元都有一个唯一的编号，这个编号就叫 内存地址。
6. 计算机的构成元件中， 负责程序的解释和运行的是CPU。

## CPU 的内部结构解析

CPU 和内存是由许多晶体管组成的电子部件， 通常称为 IC (lntegrated Circuit, 集成电路）构成的。  

从功能方面来看，CPU的内部由四个部分构成， 各部分之间由电流信号相互连通。
1. 寄存器；
   - 寄存器可用来暂存指令、数据等处理对象， 可以将其看作是内存的一种。
2. 控制器；
   - 控制器负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。
3. 运算器；
   - 运算器负责运算从内存读入寄存器的数据。
4. 时钟。
   - 时钟负责发出 CPU 开始计时的时钟信号。
   
> 有些计算机的时钟位于CPU的外部
   - 说明计算机系统中的“时钟信号”（Clock Signal）不是由CPU内部产生的，而是由主板或其他外部电路提供给CPU的。

> 程序运行流程示例：
  1. 程序员用C语言等高级语言编写程序；
  2. 将程序编译后转换成机器语言的 EXE 文件；
  3. 程序运行时，在内存中生成 EXE 文件的副本；
     - 因为 CPU 只能直接从内存（RAM）中读取和执行指令，而不能直接从硬盘上运行程序。
  4. CPU 解释并执行程序内容。

> 通常所说的内存指的是计算机的主存储器（main memory），简称主存。
  主存通过控制芯片等与 CPU 相连，主要负责存储指令和数据。
  需要注意的是，主存中存储的指令和数据会随着计算机的关机而自动清除。
  
## CPU 是寄存器的集合体

CPU 的构成部分中，程序员只需要了解寄存器即可，因为程序是把寄存器作为对象来描述的，其余部分都不用太过关注。  

> 通常我们将汇编语言编写的程序转化成机器语言的过程称为汇编；反之，机器语言程序转化成汇编语言程序的过程则称为反汇编。
  机器语言指令的本质是电子信号，我们用英语单词或其缩写（称为助记符）表示每一种信号的功能，就构成了汇编语言。
  汇编语言和机器语言基本上是一一对应的，这一点和C语言、Java等高级编程语言有很大差别。
  
通过阅读汇编语言编写的代码，能够了解转化成机器语言的程序的运行情况。机器语言级别的程序时通过寄存器来处理（即存储）的。
  - 也就是说，在程序员看来，“CPU 是寄存器的集合体”。

对于程序员来说，CPU 时具有各种功能的寄存器的集合体。
  - 其中，程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其他的寄存器一般由多个。
  - 程序计数器和标志寄存器比较特殊。

> 内存中存储数据的位置是用地址来区分的，寄存器则是用名称来区分的。
  
|种类|功能|
|---|---|
|累加寄存器（accumulator register）（第三版中改称累加器）|存储执行运算的数据和运算后的数据|
|标志寄存器（flag register）|存储运算处理后的 CPU 状态|
|程序计数器（program counter）|存储下一条指令所在内存的地址|
|基址寄存器（base register）|存储数据内存的起始地址|
|变址寄存器（index register）|存储基址寄存器的相对地址|
|通用寄存器（general purpose register）|存储任意数据|
|指令寄存器（instruction register）|存储指令。CPU 内部使用，程序员无法通过程序对该寄存器进行读写操作|
|栈寄存器（stack register）|存储栈区域的起始地址|

## CPU 解释并执行程序的过程（个人理解

1. 由操作系统在加载程序时，根据“入口点”设置程序计数器里的指令地址；
2. 控制器根据 PC 提供的地址，向内存发起读取指令；
3. 内存获取读取指令后向控制器返回对应地址中存储的指令内容；
4. 控制器进行译码分析指令类型并执行，即指挥 ALU/寄存器/内存完成操作；
5. 更新 PC 中的值；
6. 回到第二步，继续下一条指令。

## 条件分支和循环机制

程序的流程分为顺序执行、条件分支和循环三种。
  - 顺序执行是指按照地址内容的顺序执行指令；
    - 顺序执行中，每执行一个指令程序计数器的值就会自动递增以指向内存中下一条连续的指令。
  - 条件分支是指根据条件执行任意地址的指令；
  - 循环是指重复执行同一地址的指令。

> 条件分支和循环中使用的跳转指令，会参照当前执行的运算结果来判断是否跳转。
  - 标志寄存器的数值会根据运算结果自动设定，条件分支在跳转指令前会进行比较运算；
    - 至于是否执行跳转指令，则由 CPU 在参考标志寄存器的数值后进行判断。
      
## 函数的调用机制

1. 函数调用时使用call指令，而不是跳转指令；
2. call指令会把调用函数后要执行的指令地址存储在程序的栈区域内；
3. 然后将函数的入口地址设定到程序计数器；
4. 函数处理完毕后，再通过函数的出口来执行return指令；
    - return 指令的功能是把保存在栈中的地址设定到程序计数器中。

## 用基址和变址实现数组

通过基址寄存器和变址寄存器可以对主内存上特定的内存区域进行划分，按照数组的方式对其进行使用。

例如查看10000000地址~1000FFFF地址时，
   - 可以将10000000存入基址寄存器，并使变址寄存器的值在00000000~0000FFFF变化；
   - CPU 则会把基址寄存器+变址寄存器的值解释为实际查看的内存地址。

> 变址寄存器的值就相当于高级编程语言程序中数组的索引功能。

> 机器语言指令的主要类型和功能

|类型|功能|
|---|---|
|数据传送指令|寄存器和内存、内存和内存、寄存器和外部设备之间的数据读取操作|
|运算指令|用累加器执行算术运算、逻辑运算、比较运算和移位运算等操作|
|跳转指令|实现条件分支、循环、无条件跳转|
|call/return指令（调用/返回指令）|函数的调用/返回调用前的地址|

# 数据是用二进制数表示的

## 热身问答

8位=1字节，32位就是4字节；
  - “位”是数据最小单位（0 或 1），“字节”是计算机处理数据的基本单位，1 字节 = 8 个位。
反转部分图形模式时， 使用的是什么逻辑运算？
  - XOR 运算只反转与1相对应的位。NOT运算时反转所有的位。

## 用二进制数表示计算机信息的原因

计算机内部是由 IC 这种电子部件构成的，IC 上的所有引脚都只有直流电压 0V 或 5V 两个状态。也就是说 IC 的一个引脚，只能表示两个状态。  
IC 的这个特性，决定了计算机的信息数据只能用二进制数来处理。尽管二进制并不是为 IC 发明的计数法，但在用电子信号表示信息时，使用二进制时非常合适的。  
计算机处理信息的最小单位时比特，它相当于1位二进制数。比特的英文bit时binary digit（二进制数）的缩写。
  - 比特和位代表的意义没有区别，只是翻译问题导致的两种不同称呼。

> 二进制数的位数一般是8位、16位、32位......也就是8的倍数，这是因为计算机所处理的信息的基本单位是8位二进制数。  

内存和磁盘都使用字节单位来存储和读写数据，使用位单位则无法读写数据，因此字节是信息的基本单位。  
  - 用字节单位处理数据时，如果数字小于存储数据的字节数（=二进制数的位数），那么高位上就用0填补。
    - 例如，100111这个6位二进制数，用8位（=1字节）表示时为00100111，用16位（=2字节）表示时为0000000000100111.

对于用二进制数表示的信息，计算机不会区分它是数值、文字，还是某种图片的模式等，而是根据编写程序的各位对计算机发出的指示来进行信息的处理（运算）。
  - 例如00100111这样的二进制数，既可以视为纯粹的数值作加法运算，也可以视为”“文字而显示在显示器上；
    - 具体进行何种处理，取决于程序的编写方式。
  - 如果是把图片转换为二进制表达的话，CPU不知道这是图，但是显示程序会按照对应规则把它画出来。
   
## 位权

位权（Positional Weight），指的是在一个数中，某一位上的数字所代表的实际值，它由该位的位置决定。   

位权 = 基数 ^ 位数位置（从右往左，从0开始）
  - 基数：进制的“底”，比如十进制基数是10，二进制是2。
  - 位置：从右往左数，最右边第一位是第0位。

> 比如，十进制中的534，534 = 5×10² + 3×10¹ + 4×10⁰ = 500 + 30 + 4，这里的 10², 10¹, 10⁰ 就是各位的位权。
  这一点对于二进制也是一样的，二进制数00100111相当于十进制的39，我们也可以把它写成（0x128）+（0x64）+（1x32）+（0x16）+（0x8）+（1x4）+（1x2）+（1x1）=39。
  
位权的思考方式也同样适用于二进制数。即第1位是2的0次幂，第2位是2的1次幂，第3位是2的2次幂，......。

> 二进制中为什么要使用各数位的数值和位权相乘后”相加“这个处理
  - 因为在任何进制下的数字，本质上都是一个多项式展开式，十进制是这样的，这种思考方式在二进制数中也是通用的；
  - 这不是巧合，而是人类为了高效表示数字而人为规定的规则。

## 移位运算和乘除运算的关系

和十进制数一样，四则运算同样也可以使用在二进制数中，只要注意逢2进位即可。

二进制数所特有的运算，也是计算机所特有的运算，因此可以说是了解程序运行原理的关键。
1. 移位运算；
2. 乘除运算。

### 移位运算

移位运算指的是将二进制数值的各数位进行左右移位（shift = 移位）的运算。  

移位有左移（向高位方向）和右移（向低位方向）两种。  

在一次运算中，可以进行多个数位的移位操作。  

在 C 语言中，<<这个运算符表示左移，>>表示右移，运算符左侧是被移位的值，右侧表示要移位的位数；
  - 移位运算中左移后空出的低位用0填充，
  - 移位运算中，最高位或者最低位多出来的数字（称为溢出）会被直接舍弃，
  - 而用来填充右移后空出来的高位的数值，有0和1两种形式。

> 在二进制中，位权是从右往左、从 0 开始计算的！（整数部分是这样的
  从右往左，依次是0、1、2、3、4、......

#### 二进制表示负数的方法和右移的方法


二进制数中表示负数值时，一般会把最高位作为符号来使用，因此我们把这个最高位称为符号位。
  - 符号位是0时表示正数，符号位是1时表示负数。

计算机在做减法运算时，实际上内部是在做加法运算。  
  - A - B 在计算机中会被转换成 A + (-B)，而 -B 是通过求 B 的补码得到的。

旧版：  
为此在表示负数时就需要使用 “二进制的补数”，补数就是用正数来表示负数。  
获得补数的方法是，将二进制数的各数位的数值全部取反，然后再将结果加1。  
  -这里的加1是加在最低位上的。

>  00000001  
  +10000001  
  =
   10000010  
   
   二进制的加法是当两个1相加时，结果是0并产生一个进位1

第3版：  
2的补码是在二进制中用正数来表示负数的一种神奇的方法。
要得到2的补码，我们需要先将二进制数的各位数字反转，然后再将结果加1。  
例如，将-1用8位二进制数表示，就相当于求1（即00000001）的2 的补码。  
00000001的2的补码，就是将其各位数字中的0变成1，1变成0，然后将得到的结果加1，也就是11111111。  

---

二进制左移后就会变成原来的2倍、4倍、8倍......反之，二进制数右移后则会变成原来的1/2、1/4、1/8......  
因此移位运算可以代替乘法运算和除法运算。

## 逻辑右移和算数右移的区别

当二进制数的值表示图形模式而非数值时，移位后需要在最高位补0。类似于霓虹灯往右滚动的效果。这就称为逻辑右移。

将二进制数作为带符号的数值进行运算时，移位后要在最高位填充移位前符号位的值（0或1）。这就称为算术右移。

只有在右移时才必须区分逻辑位移和算数位移。  
  - 左移时，无论是图形模式（逻辑左移）还是相乘运算（算术左移），都只需在空出来的低位补0即可。

> 符号扩充：以8位二进制数为例，符号扩充就是指在保持值不变的前提下将其转换成16位和32位的二进制数。
    - 不管是正数还是用补数表示的负数，都只需用符号位的值（0或者1）填充高位即可。

## 掌握逻辑运算的窍门

将二进制数表示的信息作为四则运算的数值来处理就是算数；  
像图形模式那样，将数值处理为单纯的0和1的罗列就是逻辑。  

计算机能处理的运算，大体可分为算数运算和逻辑运算。  

  - 算数运算是指加减乘除四则运算；
  - 逻辑运算是指对二进制数各数字位的0和1分别进行处理的运算。包括
    1. 逻辑非（NOT运算）；
       - 指的是0变成1、1变成0的取反操作。
    2. 逻辑与（AND运算）；
       - 指的是“两个都是1”时，运算结果为1，其他情况下运算结果都为0的运算。
    3. 逻辑或（OR运算）；
       - 指的是“至少有一方是1”时，运算结果为1，其他情况下运算结果都是0的运算。
    4. 逻辑异或（XOR）运算。
       - 指的是排斥相同数值的运算，“两个数值不同”，也就是说，当“其中一方是1，另一方是0”时运算结果是1，其他情况下结果都是0。

以下表格总结了各逻辑运算的结果，这些表称为真值表。

逻辑非（NOT运算）的真值表
|A的值|NOT A的运算结果|
|---|---|
|0|1|
|1|0|

逻辑与（AND运算）的真值表
|A的值|B的值|A AND B的运算结果|
|---|---|---|
|0|0|0|
|0|1|0|
|1|0|0|
|1|1|1|

逻辑或（OR运算）的真值表
|A的值|B的值|A OR B的运算结果|
|---|---|---|
|0|0|0|
|0|1|1|
|1|0|1|
|1|1|1|

逻辑或（OR运算）的真值表
|A的值|B的值|A XOR B的运算结果|
|---|---|---|
|0|0|0|
|0|1|1|
|1|0|1|
|1|1|0|

掌握逻辑运算的敲门就是要摒弃用二进制数表示数值这一想法，大家不要把二进制数表示的值当作是数值，而应该把它看作是屠星或者开关时的ON/OFF（1是ON，0是OFF）。  
逻辑运算的运算对象不是数值，因此不会出现进位的情况。

# 小数运算

## 热身问答

1. 二进制数0.1，用十进制表示的话是0.5；
   - 二进制数的小数点后第一位的位权是2的负一次幂=0.5。
   
2. 用小数点后有3位的二进制数，能表示十进制数0.625吗 - 能
   - 十进制数0.625转换成二进制数是0.101。
   
3. 将小数分为符号、尾数、基数、指数4部分进行表现的形式称为浮点数（浮点数形式）；
   - 浮点数是指把小数用“符号尾数x基数的指数次幕”这种形式来表示。

4. 二进制数的基数是2；
   - 二进制数的基数是2,十进制数的基数是10。以此类推，XX 进制数的基数就是XX。

5. 通过把0作为数值范围的中间值，从而在不是用符号位情况下来表示负数的表示方法称为EXCESS系统表现；

6. 10101100.01010011这个二进制数，用十六进制数表示的话是AC.53。
   - 整数部分和小数部分一样，二进制数的4位，就相当于十六进制数的1位。

> 大家可能会认为“万能的计算实际是不会出现计算错误的。”。但实际上，仍然存在程序与逆行后无法得到正确数值的情况。  
  其中，小数运算就是一个典型的例子。
  例如，将0.1累加100次，得到的不会是10而是10.000002。
  
## 用二进制表示小数

由于计算机内部所有的信息都是以二进制数的形式来处理的，因此在这一点上，整数和小数并无差别。  
不过，使用二进制数来表示正数和小数的方法却有很大的不同。

二进制小数点后面部分的位权，从左到右从-1开始算，依次递减。  
这一规律不仅限于二进制数，在十进制数和十六进制数中也同样适用。  

## 计算机运算出错的原因

计算机之所以会出现运算错误，是因为“有一些十进制数的小数无法转换成二进制数”。  
例如，十进制数0.1就无法用二进制数正确表示，小数点后面即使有几百位也无法表示。

## 浮点数

像1011.0011这样带小数点的表现形式，完全是纸面上的二进制数表现形式，在计算机内部是无法使用的。  
很多编程语言中都提供了两种表示小数的数据类型，分别是双精度浮点数和单精度浮点数。
  - 双精度浮点数类型用64位、单精度浮点数用32位来表示全体小数；
  - 双精度浮点数和单精度浮点数能表示的正数和负数范围特别巨大，不过有些数值还是无法正确表示的。
  
浮点数是指用符号、位数、基数和指数这四部分来表示的小数。
  - 因为计算机内部使用的是二进制数，所以基数自然就是2。因此，实际的数据中往往不考虑基数，只用符号、尾数、指数这三部分即可表示浮点数。
  
浮点数的表现形式：
&plusmn;m x n<sup>e</sup>
- &plusmn;为符号
- m为尾数
- n为基数
- e为指数

浮点数的表现方式有很多种，最为普遍的是IEEE标准。  
双精度浮点数和单精度浮点数在表示同一个数值时使用的位数不同。此外双精度浮点数能够表示的数值范围要大于单精度浮点数。  

IEEE规定浮点数的内部构造：

1. 双精度浮点数（共64位）  
   符号部分（1位）+指数部分（11位）+尾数部分（52位）  

2. 单精度浮点数（共32位）  
   符号部分（1位）+指数部分（8位）+尾数部分（23位）  

符号部分是指使用一个数据位来表示数值的符号。  
  - 该数据位是1时表示负，为0时则表示“正或者0”，这和用二进制数来表示整数时的符号位是同样的。

尾数部分和指数部分并不只是单单存储着用正数表示的二进制数。  
  - 尾数部分用的是整数部分固定为1 的规格化（normal）表示法；
  - 指数部分则使用移码（excess）表示法。

#### 规格化（normal）表示法

尾数部分使用规格化表示法，可以将表现形式多样的浮点数统一为一种表现形式。  
例如，十进制数0.75就有很多种表现形式，虽然不同的表现形式都表示的同一个数值，但因为表现方法太多，计算机在处理时会比较麻烦。因此为了方便计算机处理，需要制定一个统一的规则。  
根据这个规则来表示小数的方式，就是规格化表示法。  

> 第二版中使用 "正则表达式" 来描述该表示法，含义为：**按照特定的规则来表示数据的形式**。本书成书时间较早（2007年），当时正则表达式还没有今天那么强烈的指代 "字符串格式" 的含义，而如今使用该词已经不再合适了。
> 现代一般这么使用正则：
> ```text
> 正则表达式：[+-]?\d*\.?\d+
> 匹配形如这样的字符串："0.75","-3.14",".5"
> 
> 正则表达式：\d{4}-\d{2}-\d{2}
> 匹配这样的字符串："2025-12-28","1999-01-01"
> ```
> 第三版中，使用规格化表示法，本段注释留作补充。

在二进制中，我们使用的是是整数部分固定为1的规格化表示法。
  - 具体来讲，就是将二进制数表示的小数左移或右移（这里是逻辑移位，因为符号位是独立的）数次后，整数部分的第1位变为1，第2位之后都变为0（即从第2 位起不存在有效数字）；
  - 第1位的1在实际的数据中不保存，由于第1位一定是1，因此省略该部分后就节省了一个数据位，从而也就可以表示更多的数据范围。
    - 即计算机存储的时候不存这个第1位的“1”，在内存中会把它默认加上，就可以多“赚”一位精度。
    - 单精度浮点数的尾数部分有23位，由于省略了整数部分的1，所以实际上可以表示24位的数值。
    - 双精度浮点数的规格化表示也是如此，只是使用的位数不同而已。
  
示例：
单精度浮点数尾数部分的规格化表示
  - 1011.0011 原始数值
  - 0001.0110011 右移使整数部分的第1位变成1
  - 0001.01100110000000000000000 确保小数点以后的长度为23位
  - 01100110000000000000000 仅保留小数点后面的部分，完成其规格化表示

#### 移码表示法

指数部分中使用移码表示法主要是为了表示负数时不是用符号位。  
指数部分有时需要表示“负××次幂”这样的负数，移码表示法就是将指数部分表示范围的中间值规定为0，从而可以在不使用符号位的情况下表示负数。   

例：  
指数部分为二进制数11111111（十进制数255）时，它在移码表示法中就代表128，因为255 - 127 = 128。  

## 如何避免计算机计算出错

不管是使用单精度浮点数还是双精度浮点数来处理小数，计算机都存在计算出错的可能性。  

以下是两种避免该问题的方法：  

1. 回避策略；
   - 即无视这些错误，根据程序目的的不同，有时一些微小的偏差并不会造成什么问题；
   - 一般来讲，在科学技术计算领域，计算机的计算结果只要能得到近似值就足够了，那些微笑的误差完全可以忽略掉。
   
2. 把小数转换成整数来计算。
   - 计算机在进行小数计算时可能会出错，但进行整数计算（只要不超过可处理的数值范围）时一定不会出现问题；
   - 比如本章开头讲过的将0.1相加100次这一计算，就可以转换为将0.1扩大10倍后再将1相加100次的计算，最后把结果除以10就可以了。
   
除此以外，BCD（Binary Coded Decimal）也是一种使用二进制表示十进制的方法。  
简单来讲，BCD就是用4位来表示0~9的1位数字的处理方法。  

在涉及财务计算等不允许出现误差的情况下，一定要将小数转换成整数或者采用BCD方法，以确保最终得到准确的数值。

## 二进制数和十六进制数

在以位为单位表示数据时，使用二进制数很方便，但如果位数太多，看起来就比较麻烦。  
因此，在实际程序中，也经常会用十六进制数来代替二进制数。  

在C语言程序中，只需在数值的开头加上0x（0和x）就可以表示十六进制数。  

用十六进制数来表示二进制小数时，小数点后的二进制数的4位也同样相当于十六进制数的1位。不够4位时用0填补二进制数的低位即可。  

# 熟练使用内存

## 热身问答

1. 有十个地址信号引脚的内存IC (集成电路）可以指定的地址范围用二进制数来表示的话时0000000000-1111111111（用十进制数来表示的话时0-1023）；  
   - 地址信号引脚是十个时表示2<sup>10</sup>=1024个地址。
   
2. 高级编程语言中的数据类型表示的是占据内存区域的大小和存储在该内存区域的数据类型；  
   - 例如， C 语言数据类型中的short类型，它表示的就是占据 2 字 节的内存区域，并且存储整数。

3. 在32位内存地址的环境中， 指针变量的长度是32位；
   - 指针变量存储的内容是内存地址。
   
4. 长度为1字节的数据类型的数组和内存的物理结构是相同的；
   - 内存在物理上是以1 字节为单位存储数据的。
   
5. 用LIFO方式进行数据读写的数据结构称为栈；
   - LIFO=Last In First Out。
   
6. 根据数据的大小向两侧分支的数据结构叫二叉查找树；
   - 二叉查找树是一种从节点分出两个分支的数据结构。
   
> 计算机是处理数据的机器，而程序负责规定处理步骤和数据结构。
  - 这里的数据结构是指数据在计算机中的组织、存储和管理方式；
    - 比如数组、栈；
  - 数据结构决定了数据怎么排列、数据之间有什么关系以及如何高效地访问、查找、修改这些数据。
  
## 内存的物理结构

从物理上看，内存的结构其实非常简单，但通过程序的设计，我们也可以让内存变身为各种不同的数据结构来使用。  
这绝不是什么稀罕的事情，而是很多程序中使用的一般方法。  

内存本质上是一种名为内存芯片的装置。  
内存芯片分为RAM（Random Access Memory，随机存取存储器）、ROM（Read Only Memory，只读存储器）等不同类型。  

内存芯片上有很多引脚，这些引脚负责连接电源，以及输入输出地址信号、数据信号和控制信号，通过指定地址，就可以对数据进行读写。  

> RD（read，读取的简写） WR（write，写入的简写）

一块有D0-D78根数据信号引脚、A0～A9共10根地址信号引脚的内存芯片。  
它一次可以输入输出的数据长度为8比特（=1字节），可以指定0000000000~1111111111这1024个地址。  
地址表示的是数据存储的位置，因此这块内存芯片能够存储1024个1字节的数据。由于1024=1K，所以这块内存芯片的容量是1KB。  
  - 内存的容量通常是以能存储多少字节来衡量的。

> 在计算机领域，人们习惯按照1024而不是1000进位，因为1024可以用2的整数次幂（210）表示。  
  通常，小写的“k”表示1000进位，大写的“K”表示1024进位。

要写入1字节数据到1KB内存芯片：

1. 接通电源（VCC=+5V，GND=0V）；
2. 通过地址信号A0～A9指定存储位置；
3. 将数据输入数据信号D0～D7；
4. 设置WR信号=1，完成写入。

要读取数据：

1. 通过地址信号A0～A9指定地址；
2. 设置RD信号=1，指定地址中存储的数据将通过D0～D7输出。

WR和RD是控制信号，均为0时芯片不操作。

## 内存的逻辑结构

使用楼来类比内存的话，那在这栋楼中，每一层都可以存储1 字节的数据，楼层编号就是地址。  
尽管内存的本质是内存芯片，但从程序员的角度来看，还是将它想象成一幢每层都能存储数据的大楼比较好，并不需要关心内存芯片的电源和控制信号。  

内存有一个物理上的内存所不存在的概念，那就是数据类型。  
在编程语言中，数据类型代表要存储哪一类数据，以及该数据在内存中占多少空间（大楼的层数）。  
从物理上说，内存是以1字节为单位读写数据的，但在程序中，我们通过指定类型（变量的数据类型），就可以以特定的字节数为单位来读写数据。  

通过使用变量，我们就可以在不指定物理地址的情况下在程序中完成内存的读写。  
Windows 等操作系统会在程序运行时为变量分配物理内存地址。  

同样的数，赋值给不同数据类型的变量之后占用的内存空间大小也不同。  

> 对于占用多个字节的数据，将数据的低位存放在内存低地址的方式称为“小端序”（little endian）。  
  与之相对，将数据的高位存放在内存低地址的方式称为“大端序”（big endian）

> 一般来说，在C语言中，数据类型中，8字节（ = 64 比特）的double型是最大的。

## 指针

理解指针的关键也在于数据类型这一概念。  

指针是一种变量，它不存储数据本身的值，而是存储数据所在的内存地址。使用指针可以读写任意地址的数据。  

在我们前面展示的假想内存芯片中，地址信号用10比特来表示。  
而在大家一般所使用的PC上运行的程序大多是使用32比特（4字节）来表示内存地址的，这时指针变量的长度就是32位。  

指针本质上是一个内存地址的值，它被声明为某种数据类型，并不影响地址本身的大小，而是决定了通过这个读写时，一次操作多少字节的数据。  

## 数组之于内存

数组是将相同数据类型（长度）的多个数据连续排列在内存中的一个元素序列。  
其中每个数据就是数组的元素，元素通过顺序编号来进行区分，这个编号称为下标。  
通过下标可以读写相应的内存空间，将下标转换成实际内存地址的操作是由编译器自动完成的。

C 语言中数组的下标是从0 开始的。
  - char g[100]; 表示可以使用的元素为g[0]～g[99]，共100个。

声明数组时所指定的类型也代表了对内存读写一次的长度。  
char型数组以1字节为单位，short型数组以2字节为单位，long型数组以4字节为单位对内存进行读写。  

数组之所以是使用内存的基础，是因为它反映的就是内存的物理结构本身。特别是1字节型的数组，和内存的物理结构完全一致。  
但是，如果只能以1字节为单位来进行读写的话，程序编写起来会非常麻烦，因此才提供了通过指定数据类型来声明数组的功能。  

> short h[100]的意思是在内存中申请 100 个连续的short类型变量，每个short占 2个字节（bytes），所以总共占用 200个字节 的空间。

## 栈与队列，以及环形缓冲区

栈和队列都是无须指定地址和下标就可以对数组元素进行读写的结构。  

在需要临时保存计算中间结果或计算机外部设备的输入输出数据时，经常会以这些方式来使用内存。  
为了保存临时数据，每次都指定地址和下标非常麻烦，因此人们才设计了这些方式加以改善。  

栈和队列的区别在于数据的出入顺序。  
在对内存进行读写时，
  - 栈采用的是LIFO（Last In First Out，后进先出）方式；
  - 而队列采用的是FIFO（First In First Out，先进先出）方式。
事先在内存中预留栈和队列所需要的空间，并确定数据的读写顺序，就不需要指定地址和下标了。  

要在程序中实现栈和队列，需要先声明一个包含若干元素的数组用来存放数据，然后编写用于读写元素的函数。  
当然，这些函数会在内部对下标进行管理，以便读写数组，使用了这些函数，我们人本身就不需要考虑数组和下标了。  

队列通常会以环形缓冲区（ring buffer）的形式使用。

假设我们用一个包含6个元素的数组来实现一个队列。
1. 数据会按顺序从数组开头存放进来，并按照存放的顺序取出。
2. 当数据存放到数组的末尾时，下一个数据就会回到数组开头进行存放（此时数组开头原本存放的数据已被取出，因此这个位置是空的）。
4. 通过这样的方式，数组的末尾和开头就连接在了一起，从而实现了一种可以循环存放和取出数据的结构。

## 在链表中添加和删除元素

链表和二叉查找树都是不按下标顺序对数组进行读写操作的数据结构。  
  - 使用链表可以高效地向数组中添加和删除数据（元素）。
  - 使用二叉查找树可以高效查找数组中存放的数据。

链表的实现方式是对于数组中的每个元素，不仅保存它的值，还要额外保存其下一个元素的下标。  
也就是说，数据的值和下一个元素的下标合在一起形成了数组的一个元素。  
这样，数组的元素就像项链一样被串了起来，从而形成链表。  
  - 链表的末尾元素后面没有其他元素了，因此下一个元素的下标可以设为一个不存在的值

链表通过修改“下一个元素”的下标信息来实现数据的删除与插入。  
删除时，只需将前一个元素指向被删元素的后续元素，使其在逻辑上脱离链表结构；  
插入时，可复用空闲位置，通过调整前后元素的指针关系，使新元素在逻辑顺序上处于目标位置。  
物理存储位置无需连续，逻辑顺序由指针决定。

## 用二叉查找树高效地查找数据

二叉查找树在链表的基础上做进一步的扩展，当向数组中添加元素时，根据其大小关系向左右两个方向分支。  

实现二叉树的方法：让数组中的每个元素除了保存其本身的值，再额外保存两个下标就可以了。  

二叉查找树是链表结构的扩展，自然也可以高效地添加和删除元素。  

二叉查找树的方便之处在于它可以高效地查找数据。
  - 如果使用一般的数组，我们必须从头开始按照下标顺序逐个访问元素才能找到目标数据。
  - 而在使用二叉查找树的情况下，如果目标数据比当前访问的数据小就往左侧找，比当前访问的数据大就往右侧找，由此可以快速找到目标数据。

# 内存与磁盘

## 热身问答

1. 存储程序（stored program）方式是将程序存放在存储器中并依次执行的方式。
   - 现在的计算机基本上采用的是存储程序方式。
   
2. 使用内存来提高磁盘访问速度的机制叫磁盘缓存。
   - 磁盘缓存指将从磁盘中读取的数据暂时保存在内存中，当需要再次读取相同的数据时，就可以不访问磁盘，而是直接从内存中快速读取。

3. 将磁盘的一部分模拟成内存来使用的机制叫虚拟内存（virtual memory）。
   - 虚拟内存可以让内存容量小的计算机运行大型程序。
   
4. 在Windows中，包含函数和数据，在程序运行时进行动态链接的文件叫DLL（DLL文件）。
   - DLL是Dynamic Link Library（动态链接库）的缩写。
   
5. 将函数静态链接到EXE文件中的过程叫静态链接（static link）。
   - 更白话一点解释：静态链接就是在做 EXE的时候，把需要用到的函数“打包”进程序本身，程序运行时直接用自己带的函数代码。
   
6. 在PC中，硬盘的1个扇区大小一般为512字节。
   - 扇区（sector）是磁盘的物理存储单位。
   - “硬盘”是“磁盘”的一种。
     - 磁盘是利用磁性材料存储数据的圆形盘片，是一种存储介质的统称；
     - 硬盘特指计算机中使用的固定在主机内的大容量磁性存储设备，全称是“硬盘驱动器”。

> 在计算机系统中，速度快、容量小的内存和速度慢、容量大的磁盘取长补短，相互配合完成工作。

## 程序加载到内存后才能运行

计算机中的存储器包括内存和磁盘。
存储在磁盘中的程序需要先加载到内存才能运行，不能在磁盘上直接运行。
这是因为CPU在对程序内容进行解释和运行时，是通过其内部的程序计数器指定内存地址来读取程序的。  

即便CPU能够直接读取并运行磁盘上的程序，由于磁盘读取速度慢，所以程序的运行速度也会很慢。
存储在磁盘中的程序需要先加载到内存后才能运行，这是我们在思考内存与磁盘的关系时必须明确的大前提。

## 磁盘缓存

磁盘缓存是一块内存空间，用于临时存放从磁盘读取出来的数据。  
下次需要读取相同的数据时，就不需要实际访问磁盘，而是从磁盘缓存中读取数据就可以了。  
有了磁盘缓存，就能够提高磁盘数据的访问速度了。  

将低速设备中的数据保存在高速设备中，当需要相同数据时直接从高速设备中读取，这样的设计就叫作缓存。  

## 将磁盘当成内存使用的虚拟内存

虚拟内存是将磁盘的一部分模拟成内存来使用的机制。  
有了虚拟内存，我们就可以在内存不足的状态下运行程序。  

但是，CPU只能运行已经加载到内存中的程序。  
因此，即使通过虚拟内存用磁盘来代替内存使用，实际运行的程序部分在运行时也必须存放在内存中。  
于是，为了实现虚拟内存，就需要在运行程序的过程中，对实际内存（物理内存）和磁盘上的虚拟内存中的部分内容进行置换。  

虚拟内存的实现方式分为分页式和分段式。
  - 分页式：在这种方式中，要运行的程序无论结构如何，都会被划分成一定大小的“页面”，并以页面为单位在内存和磁盘之间进行置换。
    - 将磁盘中的内容读入内存称为页面换入（page in）；
    - 将内存中的内容写入磁盘称为页面换出（page out）。
  - 分段式：操作系统会以处理集合或数据集合为单位把要运行的程序划分成段，并以段为单位在内存和磁盘之间进行置换。

## 将内存当成磁盘使用的固态硬盘

固态硬盘是将一种可读写的且断开电源后内容不会丢失的闪存（flash memory）作为硬盘来使用的产品。  
固态硬盘的本质是内存，但从用户的角度来看它就是一块硬盘。  
  - USB 驱动器、SD 卡等也是用闪存来存储的设备。

## 节约内存的编程技巧

> GUI（Graphical User Interface，图形用户界面）
  像Windows 这样通过窗口、菜单、图标等视觉元素来进行操作的方式称为GUI。
  Windows 的前身MS-DOS 则是通过键盘输入命令来进行操作的，这样的方式称为CUI（Character User Interface，字符用户界面）。

要彻底解决内存不足的问题，只能增加内存容量，或是缩减应用程序的大小。  
以下是两个缩减应用程序大小的编程技巧。  
1. 通过DLL文件共享函数；
2. 通过_stdcall 调用缩减程序大小。

### 通过DLL 文件共享函数

所谓DLL文件，顾名思义，就是在程序运行时进行动态链接的库（函数和数据的集合）。  
但是多个应用程序可以共享同一个DLL 文件。这就可以达到节约内存的效果。  

假设有一个函数MyFunc() 被应用程序A和B同时使用。  
如果采用静态链接，把MyFunc()分别嵌入到两个可执行文件中，那么当A和B同时运行时，内存中会存在两份完全相同的MyFunc()，造成内存空间的浪费、降低利用效率。  
如果不把MyFunc() 嵌入到各个EXE中，而是把它放在一个独立的DLL文件里，那么当多个程序同时运行时，它们可以共享同一个DLL，内存中只需要一份MyFunc()，从而提高了内存利用效率。  

> 此外，DLL 文件还有另一个优点，那就是在版本升级时，有时不需要更换EXE 文件，只要更换DLL 文件就可以了。

### 通过_stdcall 调用缩减程序大小

#### 1. 默认调用约定（cdecl）

- 函数参数由**调用方**压入栈中  
- 函数返回后，由**调用方**负责执行栈清理操作  
- 栈清理通常通过 `addl $8, %esp` 等指令完成

#### 2. `_stdcall` 调用约定

- 函数参数仍由**调用方**压入栈中  
- 函数返回时，由**被调用函数**负责完成栈清理  
- 调用方无需再执行清栈指令  
- 可减少重复的栈清理代码，缩小程序整体体积

> 调用方：调用函数的那段代码
  被调用方：函数本身
  默认情况：调用方负责清理参数
  _stdcall：函数自己在返回时清理参数

## 磁盘的物理结构

磁盘的表面在物理上被划分成若干区域，划分方法分为按固定长度划分的扇区方式，以及按可变长度划分的可变长方式。  

一般PC 所使用的硬盘是采用扇区方式来进行划分的。
  - 在扇区方式中，磁盘表面被划分成若干同心圆状的磁道，每条磁道再被划分成若干固定长度（存储的数据长度相等）的扇区.

### 扇区（Sector）
- 磁盘在物理上可读写的最小单位。  
- Windows系统中，一个扇区通常为512字节。

### 簇（Cluster）
- Windows在逻辑（软件）上读写磁盘的单位。  
- 一个簇由若干个扇区组成，即簇=扇区的整数倍。  
- 簇的实际长度根据硬盘容量确定。

- 规律：磁盘容量越大，簇的长度也越大。   

---

由于磁盘只能按簇来管理文件，一个簇只能属于一个文件，不能同时存放多个文件的数据。  
所以即使文件很小，也必须独占一个簇，文件在磁盘上占用的空间只能是若干个完整簇的大小。

在以簇为单位读写磁盘的情况下，一个簇中没有占满的空间就只能被闲置。
- 簇未占满的空间会闲置，导致小文件存在“空间浪费”。  
- 簇越大，浪费越多；簇越小，空间利用率越高。

如果将簇的长度变小，就会增加磁盘的访问次数，造成文件读写速度下降。
- 簇越小，同一个文件会被分割成更多簇。  
- 访问磁盘时，每个簇都需要单独定位和读取。  
- 簇数量多 → 访问次数多 → 读写速度下降。

由于磁盘需要额外的空间记录扇区的划分方式，所以如果簇的长度太小，磁盘整体的存储容量就会减少。
- 磁盘需要额外空间记录簇的使用情况。  
- 簇越小，簇数量越多，管理信息占用空间越大 → 可用存储容量减少。

扇区和簇的大小需要在处理速度和存储容量之间寻找平衡。
- 簇小：空间利用率高，但读写次数多 → 速度慢，管理信息占用空间多。  
- 簇大：读写速度快，管理信息少，但小文件浪费空间多。  
- 结论：簇大小需要在**处理速度**和**存储容量**之间寻找平衡。

# 压缩数据

## 热身问答

1. 在文件中存储数据的基本单位是1字节（8比特）。
   - 文件是字节数据的集合体。
   
2. 将文件内容表示成“数据的值×重复次数”的压缩方法，是叫游程编码。
   - 例如，“AAABB”压缩后会变成“A3B2”。
   
3. 在Windows计算机经常使用的Shift-JIS编码A中，一个半角英文或数字字符需要用1字节（8比特）的数据来表示。
   - 半角英文、数字和符号都是用1字节表示的，汉字等全角字符用2字节表示。

4. 无损压缩和有损压缩的区别：
   - 压缩后的数据可以恢复成原始数据的是无损压缩；
   - 不能恢复成原始数据的是有损压缩

## 文件的本质

文件是在磁盘等存储媒体中存储数据的一种形式。  

### 程序如何读写文件

程序以“字节（Byte）”为单位向文件中存储和读取数据 。  
  - 文件大小通常表示为：
    - KB（千字节）
    - MB（兆字节）

### 逻辑层vs物理层的差异

| 层级 | 读写单位 | 说明 |
|----|----|----|
| 程序 / 操作系统（逻辑层） | 字节 | 程序“感觉”自己在按字节操作 |
| 磁盘硬件（物理层） | 扇区（512B） | 实际读写必须按扇区进行 |

### 总结

无论如何，我们都可以认为文件就是一串连续存储的字节数据。  

程序以字节为单位操作文件，但磁盘以扇区为单位读写数据，操作系统负责在两者之间做转换。

## 游程编码

将文件内容用“数据× 重复次数”来表示的压缩方法称为游程编码（run length encoding）。  

### 适用场景与优点
- 对于相同数据连续重复较多的文件，压缩效果显著；
- 常用于：
  - 传真图像压缩等。
- 算法简单，实现成本低。

### 游程编码的缺点

#### 不适合文本文件
- 实际的文本文件中：
  - 同一个字符连续多次出现的情况较少
- 使用游程编码：
  - 压缩率低
  - 在某些情况下甚至可能增大文件体积

#### 不适合程序指令数据

表示程序指令的字节数据也很少有连续重复出现的情况。

## 哈夫曼算法（Huffman Coding）

### 基本思想

在一个文本文件中，不同字符的出现频率不同。  
哈夫曼算法的核心思想是：
  - 高频数据 → 使用较短的编码；
  - 低频数据 → 使用较长的编码。
通过这种方式，使整体编码长度最小，从而达到压缩的目的。  

### 编码长度的变化

普通编码（如 ASCII）：
  - 每个字符固定使用 8 比特。
哈夫曼编码：
  - 出现次数多的字符 → 小于 8 比特；
  - 出现次数少的字符 → 大于 8 比特。
平均编码长度因此降低。  

### 文件相关性（最优性）
哈夫曼算法并不是使用固定的编码表，每个文件都会根据自身的数据分布构建最优的编码系统。  
因此：
  - 不同文件中，相同字符对应的哈夫曼编码可能不同。

### 压缩文件的组成

经过哈夫曼算法压缩的文件通常包含两部分：
  1. 哈夫曼编码信息（或哈夫曼树）；
  2. 压缩后的数据。
解压时必须先读取编码信息，才能正确还原原始数据。

### 哈夫曼树

哈夫曼算法通过构建哈夫曼树来生成编码系统。
哈夫曼树的特点：
  - 任意一个字符的编码，都不会是另一个字符编码的前缀；
  - 不需要额外的分隔符即可区分不同字符。
即使不同字符的编码长度不同，也能被正确解析。

### 哈夫曼树的构建思想

构建过程中采用的基本策略是：不断将出现频率最低的节点连接起来。  
结果是：
  - 低频数据距离根节点较远；
  - 编码路径更长 → 比特数更多。
高频数据路径更短 → 编码更短。

### 解码过程

解码时：
  - 从压缩数据的开头开始，逐比特读取；
  - 同时在哈夫曼树中向下遍历；
  - 一旦到达叶子节点，即确定一个字符。
通过哈夫曼树，可以准确判断字符之间的分隔位置。  

### 算法复杂度与特点

相比游程编码：
  - 哈夫曼算法的实现更复杂；
  - 需要构建和存储哈夫曼树。
但优点是：
  - 对各种类型的文件通常都能获得较好的压缩率；
  - 不依赖于数据是否连续重复。

### 总结

哈夫曼算法是一种：
  - 无损压缩；
  - 基于统计特性的变长编码方法。
核心优势在于：
  - 根据数据出现频率自动生成最优编码。
与游程编码相比：
  - 适用范围更广；
  - 压缩效果更稳定。

## 无损压缩与有损压缩

### BMP 格式与原理

Windows 标准图像数据的格式是 BMP，这是一种完全未经压缩的格式。由于显示器或打印机输出的点（bit）可以直接进行映射（mapping），所以使用了 BMP（bitmap）这个名称。

### 其他图片格式与压缩

除 BMP格式之外，还有很多其他类型的图片文件格式，例如 JPEG格式、GIF格式、PNG格式等。BMP之外的大多数图像数据格式采用了一定的方法对数据进行压缩。

### 图片压缩特点

对于图片文件，我们可以使用与之前介绍的游程编码、哈夫曼算法不同的压缩方法。这是因为在大多数情况下，在质量方面，压缩后的图片文件没有必要和原来的完全相同。

### 文本与程序文件的特殊性

EXE 程序文件，以及每个字符和数字都有意义的文本文件，必须能够准确地恢复为压缩前的内容，而图片文件即便无法准确恢复到压缩前的状态，只要人眼感觉不到差异，就允许损失一些质量。

### 压缩方法的多样性

压缩方法大概有 10～20 种。之所以存在这么多种压缩方法，除了因为它们的压缩率不同，还因为压缩所需要的处理时间（程序复杂度）以及适用于哪种文件有所不同。

### 万能压缩方法尚未出现

因此，称得上最好的、万能的压缩方法，现在还没有被设计出来。

# 程序在怎样的环境下运行

## 热身问答

1. 应用程序的运行环境用操作系统和硬件来表示。  
   - 一般来说，应用程序的运行环境是指操作系统的类型以及硬件（CPU、内存等）的类型和性能指标。
   
2. Windows应用程序不能直接在macOS上运行吗。  
   - 应用程序是为了在特定操作系统上运行而开发的。
   
3. PC可以安装除Windows以外的操作系统。
   - PC上也可以安装Ubuntu、RHEL（Red Hat Enterprise Linux）等Linux发行版操作系统。
   
4. Java虚拟机的功能是运行编译为字节码的Java程序。  
   - 只要针对不同的环境准备专用的Java虚拟机，就可以让相同的字节码在各种环境中运行。
   
5. SaaS、PaaS、IaaS这几种类型的云计算中，提供虚拟硬件的是IaaS。  
   - SaaS提供应用程序，PaaS提供操作系统，IaaS提供硬件。
   
6. 引导装入程序（bootstrap loader）的功能是启动操作系统。
   - 计算机内部ROM中存储的BIOS程序负责启动引导装入程序，引导装入程序负责启动存储在硬盘等媒体中的操作系统。

## 运行环境=操作系统+硬件

程序的运行环境是通过操作系统和硬件（处理器、内存等）来表示的，也就是说，操作系统和硬件决定了程序的运行环境。

微软Office 2019运行环境（节选）
|项目|要求|
|---|---|
|操作系统|Windows 10、Windows Server 2019|
|处理器|1.6GHz以上，双核心|
|内存|4GB（64位版本）、2GB（32位版本）|
|硬盘剩余空间|4GB|
|显示器分辨率|1024 × 768 像素|

一台计算机可以安装多种操作系统。例如，PC不仅可以安装Windows，还可以安装Linux操作系统。因此，Office 2019的运行环境需要同时规定操作系统和硬件类型。  
但是，只说Windows或Linux还不够，因为操作系统有很多版本，有些应用程序可能只能在特定版本的操作系统中运行。  

### 源代码与本机代码

在将硬件作为程序运行环境考虑时，CPU的类型非常重要。  
CPU只能解释特定种类的机器语言，不同类型的CPU能解释的机器语言也不同。除了x86，CPU的种类还包括MIPS、SPARC、PowerPC等，它们各自所使用的机器语言都是不同的。  

机器语言的程序也称为本机代码（native code）。程序员使用C语言等编写的程序，在编写阶段都只是普通的文本文件。
在任何环境下文本文件（不考虑字符编码问题的话）都可以显示和编辑，这样的文件被称为源代码（source code）。
对源代码进行编译，可以得到本机代码。在大多数情况下，应用程序不是以源代码的形式分发的，而是以本机代码的形式分发的。  

## Windows 消除了CPU之外的硬件差异

在Windows应用程序中，键盘输入、显示器输出等操作不是通过直接访问硬件来实现的，而是通过向Windows 发出请求来间接地实现的。
这样一来，程序员就不需要关注内存和I/O地址的差异了，因为Windows代替了应用程序对各种不同机型的硬件进行操作。

## 每种操作系统的API都是不同的

同一种机型的计算机也可以安装多种操作系统。以PC为例，除Windows之外，它也可以安装Ubuntu、RHEL 等Linux发行版。  
如果说CPU类型的差异代表机器语言的差异，那么操作系统的差异就代表应用程序向操作系统发出请求方式的差异。  

应用程序向操作系统发出请求的方式是由API（Application Programming Interface，应用程序接口）来决定的。  
Windows和Linux的API提供了可被任意应用程序使用的函数集合。  
由于不同的操作系统提供的API不同，所以如果要将一个应用程序移植到另一个操作系统上，就必须重新编写其中使用API的部分。  
API提供了键盘输入、鼠标输入、显示器输出、文件输入/输出等与外部设备之间输入/输出的功能。  

在同一个操作系统中，无论使用怎样的硬件，API都是基本相同的。  
因此，按照操作系统的API编写的程序，在任何硬件上都可以运行。  

如果CPU类型不同，机器语言也会不同，本机代码不可能保持不变。  
在这种情况下，我们需要使用对应的编译器重新编译源代码，以便生成适配各种CPU 的本机代码。  

## 使用源代码进行安装

针对不同CPU架构间机器代码不可通用的问题，分发源代码并由用户在目标平台上自行编译，是一种有效的解决方案，典型应用于Linux软件生态中。  

在Linux中安装新程序时，我们可以选择包含所有必要程序的软件包，也可以选择通过源代码来安装。  

Linux程序的源代码大多是用C语言来编写的，这些源代码可以从遍布互联网的Linux仓库中获取。  
Linux内置了标准的C语言编译器，使用该编译器就可以按照当前Linux的运行环境生成对应的本机代码。  

## Java虚拟机

不将源代码编译为本机代码，而是一种中间代码，就可以提供不依赖特定操作系统和硬件的运行环境了，Java使用的就是这种方法。  
  - Java这个词有两个含义，一个是Java编程语言，另一个是Java程序运行环境。

和其他编程语言一样，用Java编写的源代码也需要经过编译才能运行，但是编译后生成的并不是针对特定CPU的本机代码，而是一种称为字节码（bytecode）的代码。  
字节码的运行环境称为Java虚拟机（Java Virtual Machine，Java VM）。Java虚拟机会将Java字节码逐一转换为本机代码来执行。  

编译后的字节码需要在运行时转换成本机代码，这个方法看起来有点绕弯子，但它可以让相同的字节码在不同的环境中运行。  
只要为各种操作系统和硬件开发对应版本的Java虚拟机，就可以让相同的字节码应用程序在所有环境中运行了。  
Java的这种特性被称为“Write once, run anywhere”（一次编写，处处运行）。  

### 缺点

1. 兼容
   - 不同的Java 虚拟机之间并不能做到完全兼容。Java 虚拟机很难做到运行任何字节码程序这一点。
2. 运行速度
   - 需要在运行时将字节码转换成本机代码的Java程序，在运行速度上比直接编译成本机代码的C语言程序要慢。

## 云计算平台提供的虚拟运行环境

通过互联网来使用硬件、操作系统、应用程序等计算机资源的技术称为云计算（cloud computing）。  
 
根据其所提供的具体服务，云计算可分为
1. SaaS（Software as a Service，软件即服务）；
2. PaaS（Platform as a Service，平台即服务）；
3. IaaS（Infrastructure as a Service，基础设施即服务）。
   - IaaS也称为HaaS（Hardware as a Service，硬件即服务）。

简单来说，SaaS 提供的是应用程序，PaaS 提供的是操作系统，IaaS 提供的是硬件。  

在SaaS、PaaS和IaaS中，PaaS和IaaS可作为程序的运行环境使用。  
PaaS提供的是操作系统，因此我们可以在这个操作系统上运行开发的程序。  
IaaS提供的是硬件，因此我们可以在这个硬件上安装Windows、Linux等操作系统，然后在安装的操作系统中运行开发的程序。  

## BIOS与引导装入程序

程序的运行环境还包括BIOS（Basic Input Output System，基本输入输出系统）。  
BIOS存储在ROM中，是预先内置在计算机中的一段程序。  
BIOS除了提供键盘和磁盘设备的基本控制程序，还负责启动引导装入程序。  
  - 引导装入程序是存储在启动磁盘开头的一段很短的程序。
  
> 启动磁盘一般是硬盘，但光盘和USB 驱动器也可以作为启动磁盘使用。  

打开计算机电源后，BIOS 会先检查硬件是否能够正常工作，如果一切正常就启动引导装入程序。  
引导装入程序的功能是将存储在硬盘上的操作系统加载到内存并运行。  

> 启动应用程序是操作系统的工作，而操作系统不能启动自己，因此操作系统的启动需要由引导装入程序来完成。

# 从源文件到可执行文件

## 热身问答

1. 将多个目标文件拼接成一个EXE文件的工具叫链接器。
   - 通过编译和链接可得到EXE文件。
   
2. 对源文件进行编译可得到目标文件。
   - 例如，对源文件sample.c进行编译可得到目标文件sample.obj。目标文件的内容就是本机代码。
   
3. 由多个目标文件打包而成的文件叫库文件（library file）。
   - 链接器会从库文件中提取必要的目标文件并将它们拼接成一个EXE文件。
   - 在程序运行时进行动态链接的DLL文件也属于库文件。
   
4. 包含DLL文件中的函数调用信息的文件叫导入库（import library）。
   - 将导入库中的信息链接到EXE文件，由此程序就可以在运行时调用DLL中的函数了。
   
5. 程序运行时动态分配的内存空间叫堆（heap）。
   - 堆是一种可以根据程序自身的请求来分配和释放的内存空间。

> 本章中我们会把重点放在编译器和链接器的功能上，笔者会向大家介绍程序从编写到运行的整个过程。  
  最开始我们会看一下源文件是如何转变成可执行文件的，然后看一看可执行文件加载到内存并运行的内部机制。  
  笔者也会讲解程序运行时在内存中生成的栈和堆分别是什么样的。

## 计算机只能执行本机代码

使用某种编程语言编写的程序称为源代码（source code），将源代码保存成一个文件就称为源文件（source file）。
  - C语言的源文件扩展名约定为“.c”；
  - 源文件只是一个普通的文本文件，用Windows自带的“记事本”等文本编辑器就可以编辑。

CPU能直接解释和执行的只有本机代码，它只能理解本机代码形式的程序。

对CPU来说，用它的母语机器语言来编写的程序就是本机代码。  
用其他编程语言编写的源代码，必须翻译成本机代码才能够被CPU理解和执行。  
反过来说，不同编程语言所编写的源代码翻译成本机代码之后就变成了同一种语言（机器语言）。  

## 本机代码的内容

Windows的EXE文件中的程序内容就是本机代码。  

本机代码的内容并不是人类能够理解的，所以我们才需要先用人类更容易理解的C 语言等编程语言来编写源代码，然后将其翻译成本机代码。  

将EXE文件的内容进行转储。  
  - 转储（dump）是指将文件内容按1字节2位十六进制数的形式显示出来。
  
我们发现，本机代码的内容就是数值序列，这就是本机代码的本质。其中每个数值都代表某个指令或者数据。  

## 编译器负责翻译源代码

负责将用C语言等高级语言编写的源代码翻译成本机代码的程序称为编译器。  
用不同的编程语言编写的源代码需要使用该语言专用的编译器来进行编译。  
  - 用于将C语言源代码翻译成本机代码的编译器称为C编译器。  
 

编译器会读取源代码的内容并将其翻译成本机代码。  
  - 可以大致理解为编译器中有一张源代码和本机代码的对应表，但实际上仅靠对应表是无法生成本机代码的。
  - 编译器需要对读取的源代码进行词法分析、语法分析、语义分析等处理，这样才能够生成本机代码。  

CPU的类型不同，其对应的本机代码也不同。因此，不仅不同的编程语言所使用的编译器不同，不同类型的CPU所使用的编译器也不同。  
例如，用于x86架构CPU的C编译器和用于PowerPC架构CPU的C编译器就是不同的。  

编译器本身也是一种程序，因此也有其对应的运行环境。  
例如，有Windows 版的C 编译器，也有Linux版的C编译器。  
同时，也有一些编译器本身运行在一种CPU上，但它能够生成适配另一种CPU 的本机代码，这样的编译器称为交叉编译器（cross compiler）。  

## 仅靠编译无法得到可执行文件

仅靠编译无法得到可执行文件作为源代码的翻译结果，编译器生成的是包含本机代码的文件，但这个文件不能直接运行。  
要得到可执行的EXE文件，在编译之后还需要进行链接操作。  

程序的完整构建不仅依赖于程序员编写的函数（如 Average() 和 WinMain()），还需要链接系统提供的标准库或外部函数（如 sprintf() 和 MessageBox()）。  
这些外部函数的实现不包含在源代码中，必须通过链接对应的目标文件（.obj）将其实际内容合并到最终可执行文件中，否则将因缺少函数定义而无法生成完整的EXE程序。  

将多个目标文件拼接在一起生成一个EXE 文件的过程称为链接，用于完成这一操作的程序称为链接器（又称链接编辑器或链接程序）。  

## 启动代码与库文件

链接时的选项“-Tpe -c -x –aa”代表要生成用于Windows的EXE文件。  
在这些选项后面，我们指定了要链接的目标文件。可以看到指定了c0w32.obj和sample.obj这两个目标文件。  
其中，sample.obj是sample.c 编译后生成的目标文件，c0w32.obj包含了一些通用代码，需要链接在所有程序的开头，这些代码被称为启动代码（startup code）。  
即便一个程序没有调用位于其他目标文件中的函数，也必须链接启动代码。  

sprintf() 等函数属于标准函数，其具体实现并不包含在源代码中，而是预先编译成目标文件并打包在库文件（如静态库）中，随编译器一同分发。  
使用库文件可以将大量常用函数集中管理，避免在链接时逐个指定多个目标文件。  

## DLL 文件与导入库

Windows 操作系统中包含可供应用程序使用的各种功能，这些功能都是以函数的形式来提供的， 这样的函数称为Windows API（Application Programming Interface，应用程序接口）。  
例如，sample.c中调用的MessageBox() 并不是C 语言规范中的标准函数， 而是Windows 提供的API 的一部分。  
  - MessageBox() 函数提供了显示消息框的功能。

Windows API的目标文件通常不是以库文件的形式存在的，而是以一种称为DLL（动态链接库）的特殊库文件的形式存在的。
正如其名称中的“动态”一词所表示的那样，DLL文件是在程序运行时才进行链接的。

之前讲过，MessageBox() 的目标文件位于import32.lib 中，但实际上import32.lib中只包含MessageBox() 位于DLL文件user32.dll 中这一信息，以及这个DLL文件所在的目录，并不包含MessageBox() 的目标文件本身。  
像import32.lib这样的库文件称为导入库。  

与之相对，包含目标文件本身，可以直接链接到EXE 文件的库文件称为静态链接库（static link library），其中“静态”与“动态”是一对反义词。  
sprintf() 的目标文件所在的cw32.lib 就属于静态链接库。  
sprintf() 函数提供了将数值按指定格式转换成字符串的功能。  

将导入库链接到EXE文件，就相当于链接了运行时从DLL文件中调用MessageBox() 函数所需的信息。  

> 对于以上整个编译和链接过程的示例在图8-8中描绘的非常清晰。

## 运行可执行文件需要什么

尽管EXE文件中包含完整的本机代码程序，但变量和函数在内存中的实际地址是不确定的。  
像Windows 这种支持同时加载多个可执行程序的操作系统，每次运行程序时都会为程序内部的变量和函数分配不同的内存地址。  

在EXE文件中，变量和函数被分配的内存地址都是虚拟的，在程序运行时，这些虚拟的内存地址会转换成实际的内存地址。  
链接器会在EXE文件的开头记录需要进行内存地址转换的各个位置，这些信息被称为重定位信息。  

在EXE文件中，重定位信息中记录的是变量和函数的相对地址。  
  - 所谓相对地址，就是某个地址与基地址之间的相对距离，也就是偏移量。
要想使用相对地址，就需要进行一些额外的处理。  
在源代码中，变量和函数都是分散在各个位置的，但在链接后的EXE 文件中，变量和函数会被集中起来分成两组连续排列。  
于是，每个变量的内存地址就可以表示为该变量相对于变量区起始位置的偏移量，每个函数的内存地址也可以表示为该函数相对于函数区起始位置的偏移量。  

### 重定位是怎么实现的？（技术简述）

1. 编译器/链接器生成“重定位表”
   - 在生成可执行文件或 DLL 时，工具链会记录：哪些位置的指令或数据包含了“绝对地址引用”。
     - 比如：mov eax, 0x405000 这个地址可能需要修改。
   - 操作系统加载程序时检查加载地址

2. 如果实际加载地址 ≠ 预期地址，系统就知道需要“重定位”。
   - 根据重定位表逐一修正地址

3. 把所有原本基于 0x400000 的绝对地址，加上偏移量（如 +0x100000），变成新的正确地址。  

## 加载时生成的栈和堆

至此我们知道，EXE文件的内容分为重定位信息、变量区和函数区。  
但是，在加载程序的内存空间中，还会生成另外两个区域，它们就是栈和堆。  
  - 栈是用来存放函数内部临时使用的变量（局部变量A）以及调用函数时传递的参数等数据的内存空间。
  - 堆是在程序运行时用来存放任意数据的内存空间。

EXE文件中并不包含栈和堆的区域，EXE文件加载到内存并运行的那一刻，栈和堆所需的内存空间才得到分配。  
因此，内存中的程序是由变量空间、函数空间、栈空间和堆空间共4个区域组成的。  
当然，内存中还有另外一块专门用于加载Windows 操作系统的空间。  

栈和堆都是在程序运行时分配的内存空间，在这一点上两者是相似的。但是，两者在对内存的使用方法上稍有区别。  
  - 栈和堆的大小可以由程序员来指定。在用高级编程语言编写程序时，编译器会自动生成用于指定栈空间和堆空间大小的代码并将其添加到程序中。
  
栈数据的存放和丢弃（清空操作）是由编译器自动生成的代码来完成的，不需要程序员关注。  
  - 一个函数被调用时，会自动分配栈空间来存放数据，并在函数执行完毕返回时自动释放。
与之相对，内存中的堆空间需要程序员通过程序显式地进行分配和释放。  

对于堆空间的分配和释放，各种编程语言都有不同的写法。
如果不在程序中显式地释放堆空间，那在程序运行结束后，这些空间就依然处于占用状态。这一现象称为内存泄漏（memory leak）。

## 进阶问答

1. 编译器和解释器的区别是什么？
   - 编译器是在程序运行之前对整个源代码进行翻译；
   - 解释器则是在程序运行时对源代码逐行进行翻译。
   
2. 什么是多文件编译？
   - 多文件编译是指将一个程序分为多个源文件，并对其分别进行编译，最后合并生成一个EXE文件。
   - 这样做的好处是可以缩短单个源文件的长度，方便对程序代码进行管理。
   
3. 什么是构建（build）？
   - 在某些开发工具中，点击菜单中的“构建”命令就可以生成EXE文件。在这里，构建就是指连续执行编译和链接这两个操作。

4. 不链接导入库，就无法调用DLL文件中的函数吗？
   - 即使不链接导入库， 程序也可以使用LoadLibrary() 和GetProcAddress() 等API在运行时调用DLL文件中的函数，但使用导入库比较简单。

5. 什么是“垃圾收集”？
   - 垃圾收集（garbage collection）是指将堆空间中已经不再需要的数据进行清理，从而释放被占用的内存空间。这里将不再需要的数据比作垃圾。
   - 在Java、C# 等编程语言中，程序会在运行时自动执行垃圾收集，这一机制是为了防止程序员粗心（忘记释放内存）导致的内存泄漏。

# 操作系统与应用程序的关系

## 热身问答

1. 监控程序（monitor program）的主要功能是加载并运行程序。
   - 监控程序可以说是操作系统的原型。
   
2. 在操作系统上运行的程序叫应用程序。
   - 文字处理软件、表格处理软件等都属于应用程序。
   
3. 调用操作系统提供的功能叫系统调用。
   - 应用程序通过系统调用来间接地控制硬件。
   
5. GUI的全称是Graphical User Interface（图形用户界面）。
   - 可以通过用鼠标点击屏幕上的窗口、图标等可视化方式进行操作的用户界面。
   
6. WYSIWYG的全称是What You See Is What You Get（所见即所得）。
   - WYSIWYG的意思是，显示器上显示的东西可以直接通过打印机打印出来，即“所见即所得”，这是Windows的特点之一。

## 从历史发展看操作系统的功能

> 操作系统（Operating System，OS）也被称为基础软件，它是负责控制计算机工作的程序以及为用户提供基本操作环境的软件的统称。在操作系统中运行的程序则统称为应用程序。

操作系统的原型是只具备加载和运行程序功能的监控程序，可以根据需要将各种程序加载到内存中并运行。  

人们在使用监控程序的前提下开发了各种程序，并在此过程中发现了很多程序通用的部分。  
  - 例如，从键盘输入字符，将字符输出到屏幕的部分等。
因此人们将提供基本输入输出功能的程序添加到了监控程序中，这就是早期的操作系统。  

随着时代的进一步发展，为了给程序员提供便利，人们又在操作系统中增加了硬件控制程序、语言处理器（汇编器、编译器、解释器）以及各种工具，使其最终形成了接近现代操作系统的形态。  
操作系统不是一个单独的程序，而是多个程序的集合体。  

## 关注操作系统的存在

编写应用程序的程序员需要意识到自己所编写的程序并不是直接使用硬件的功能，而是使用操作系统的功能。  
程序员当然要具备硬件的基础知识，但由于操作系统的存在，程序员并不需要编写直接访问硬件的程序。  

在操作系统环境中运行的应用程序并不会直接访问硬件，而是通过操作系统间接地访问硬件。  
无论是声明变量分配内存空间，还是time() 函数和printf() 函数的运行结果，都并非直接作用于硬件，而是作用于操作系统。  
操作系统接受并解析来自应用程序的请求，然后分别访问时钟芯片（实时时钟）和显示器I/O。  

## 系统调用与高级编程语言的可移植性

操作系统的硬件访问功能通常会以大量小型函数的集合体的形式来提供。  
这些函数及调用这些函数的行为统称为系统调用（sytem call），也就是应用程序调用（call）操作系统（system）的功能。  

C 语言等高级编程语言不依赖于特定操作系统。无论是Windows还是Linux，基本可以使用相同的源代码。  
要实现这一点，在高级编程语言中就需要使用专用的函数名，并在编译时将其转换成对应操作系统的系统调用（或多个系统调用的组合）。  
也就是说，用高级编程语言编写的程序在编译后会变成包含系统调用的本机代码。  

也有一些高级编程语言支持直接进行系统调用，但是以这种风格编写的程序，其可移植性很差。  
例如，直接使用Windows系统调用的程序肯定无法在Linux中运行。  

## 操作系统和高级编程语言对硬件进行了抽象化

通过操作系统提供的系统调用，程序员就不需要编写直接访问硬件的程序了。  
而且，使用高级编程语言编程也使程序员不需要关注系统调用的存在。  

## Windows 操作系统的特点

Windows 操作系统的主要特点如下。
1. 有32 位和64 位两个版本
2. 通过API 函数集提供系统调用
3. 采用GUI
4. 能以WYSIWYGA 的方式打印输出
5. 提供多任务功能
6. 提供网络和数据库功能
7. 可通过即插即用自动安装设备驱动程序

### 有32位和64位两个版本

这里的32位或64位，指的是能够最为有效地进行处理的数据长度。  
Windows处理数据的基本单位，对32位版来说就是32位，对64位版来说就是64位。  

但是，64位版Windows中也可以运行32位版Windows的应用程序。  
因此目前，为了保证兼容性，很多应用程序是32位的，很多C编译器生成的也是适配32位CPU的本机代码。  

### 通过API函数集提供系统调用

Windows是通过名为API 的函数集来提供系统调用的。  
API是连接应用程序开发者与操作系统的窗口（接口），因此得名API。  
32位版Windows的API称为Win32 API，64位版Windows的API称为Win64 API。  

API是以若干DLL文件的形式来提供的，每个API的本体都是C语言编写的函数，因此C语言程序很容易使用这些API。  

### 采用GUI

GUI是指能够通过用鼠标点击屏幕上的窗口、图标等元素来进行可视化操作的用户界面。  

对用户来说，GUI就是图形和鼠标，而对程序员来说就没有那么简单了，编写一个能实现GUI的应用程序非常难。  

对于在采用GUI的操作系统中运行的应用程序来说，操作的流程是由用户决定的。  
因此，程序员必须确保程序无论按怎样的顺序操作都不会出问题。  

### 能以WYSIWYG的方式打印输出

WYSIWYG是指屏幕上显示的内容可以按原样打印出来。在Windows中，屏幕和打印机在图像的输出上被视作同等的设备，由此实现了WYSIWYG。  

### 提供多任务功能

多任务（multitask）是指同时运行多个程序的功能。

Windows使用时间片的方式来实现多任务。  

时间片是指以很短的时间间隔在多个程序之间切换运行，在用户看来就好像是多个程序在同时运行一样。  
Windows会负责在多个运行的程序之间进行切换。  
Windows还提供了以单个函数为单位分割时间片的多线程（ multithread）功能。  

### 提供网络和数据库功能

Windows系统内置了标准的网络功能，服务器版Windows还可以添加数据库（数据库服务器）功能。  

数据库并不是操作系统不可或缺的功能，但它与操作系统很接近，所以一般不将其称为应用程序，而是称为中间件（middleware），也就是介于操作系统和应用程序中间（middle）的软件。  

操作系统和中间件也统称为系统软件（system software）。  
应用程序除了可以直接使用操作系统的功能，还可以使用中间件提供的功能。  

操作系统在安装之后就很难更换了，但中间件可以根据需要进行更换。  
但是，在很多情况下，改变了中间件也就意味着应用程序需要做出相应的改变，因此我们也不能轻易改变中间件。  

### 可通过即插即用自动安装设备驱动程序

即插即用（plug-and-play）是一种让新设备插入（plug）之后就可以立即使用（play）的机制。  
当新设备连接到计算机后，操作系统可以自动安装并配置用于控制该设备的设备驱动程序（device driver）。  

设备驱动程序是操作系统的一部分，负责提供对硬件的基本输入输出功能。  

对于键盘、鼠标、显示器、磁盘、网络等一般计算机必备的硬件设备，它们的驱动程序已经随操作系统预先安装好了。  
当需要添加打印机、无线局域网（Wi-Fi）等硬件设备时，就需要向操作系统中安装相应的设备驱动程序。  

设备驱动程序会在安装其主体文件时，一起安装DLL文件。这些DLL文件中包含了用来访问新硬件设备的API（函数集）。  
使用这些API，就可以开发能够使用新硬件功能的应用程序。  

能够任意添加设备驱动程序和API 的机制提高了Windows操作系统的灵活性。  
所谓的灵活，就是指能够适配将来会出现的新硬件设备。  

# 通过汇编语言认识程序的真面目

## 热身问答

1. 在汇编语言中，用来表示各个本机代码功能的英文缩写叫助记符（mnemonic）。
   - 汇编语言是使用助记符来编写程序的。
   
2. 将汇编语言源代码转换成本机代码的过程叫汇编。
   - 汇编需要使用汇编器来完成。
   
3. 将本机代码反过来转换成汇编语言源代码的过程叫反汇编（disassemble）。
   - 通过反汇编可以得到人类能够理解的源代码。
   
4. 汇编语言源文件的扩展名是.asm和.s等。
   - 汇编语言源文件的扩展名在Windows 中主要是.asm，在Linux中主要是.s。
   - 不过，本章中使用的C语言编译器BCC32虽然是在Windows环境下运行的，但使用了.s作为汇编语言源文件的扩展名。
   
5. 汇编语言程序中的段是将构成程序的指令和数据分别汇总形成的组。
   - 在高级编程语言的源代码中，指令和数据都是分散在各个位置的，但在编译后它们会被分别汇总到不同的段中。
   
6. 汇编语言的跳转指令是让程序流程跳转到任意地址的。
   - 汇编语言中可以使用跳转指令实现循环和条件分支。

> 将一起看看用C语言编写的函数调用、局部变量、全局变量、条件分支、循环等语句，在转换成汇编语言之后会变成什么样子。

## 汇编语言和本机代码是一一对应的

用C语言等编写的源代码，需要使用各个编程语言相对应的编译器进行编译，转换成本机代码。  
因此，查看本机代码就可以看到程序最终在运行时变成了什么样子。  
但是，在人类看来，本机代码就是一串数字，直接用数字来编写程序无异于写天书。  
于是，人们发明了一种方法，为每个本机代码的指令分配一个英语缩写来表示其功能。  
例如，  
  - 把对32 位数据进行加法运算的本机代码称为addl（addition long 的缩写）；
  - 把进行比较的本机代码称为cmpl（compare long 的缩写）。
这些缩写称为助记符，使用助记符的编程语言称为汇编语言。  
查看用汇编语言编写的源代码，我们也能了解程序的真面目，因为它与本机代码是等价的。  

即使是用汇编语言编写的源代码，最终也必须转换成本机代码才能运行。  
用来完成这种转换的程序称为汇编器，这个转换的过程称为汇编。  
在将源代码转换成本机代码这一点上，可以说汇编器和编译器的功能是相同的。  

用汇编语言编写的源代码和本机代码是一一对应的，因此我们也可以将本机代码反过来转换成汇编语言的源代码。  
具有这种反向转换功能的程序称为反汇编器（disassembler），这种反向转换的过程称为反汇编。  

用C语言编写的源代码，在编译之后也会转换成适配特定CPU的本机代码。  
再对本机代码进行反汇编，我们就可以得到汇编语言源代码，从而可以查看其内容。但是，将本机代码反编译成C语言源代码要比反汇编困难得多。  
这是因为C语言源代码和本机代码并不是一一对应的，我们不能保证得到和编译之前相同的源代码。  

## 用C编译器输出汇编语言源代码

除对本机代码进行反汇编之外，我们还可以通过其他方法得到汇编语言源代码。  
大部分C语言编译器提供了将C语言源代码转换成汇编语言源代码的功能。  

## 伪指令与注释

在详细讲解源代码的内容之前，我们先来了解一下伪指令（pseudo instruction）和注释。  

汇编语言源代码中的指令分为两种，一种是会被转换成本机代码的一般指令，另一种是专门针对汇编器的伪指令。  
伪指令负责告诉汇编器程序的结构和汇编的方法，因此也被称为汇编程序指令（assembler directive）。  

这里我们不需要知道所有伪指令的意义，大家只要记住.section就可以了。  
.section 的功能是标记接下来的程序属于哪个段。  
  - 段就是一组指令和数据的集合。

段的定义语法为.section 段名, " 属性"。在属性的部分中，"x" 代表execute（执行），"r" 代表read（读），"w" 代表write（写）。  
例如，.section _TEXT, "xr" 这条伪指令的意思是，接下来的程序是一个名为_TEXT、属性为可执行且只读的段。  

在汇编语言源代码中，以#开头的部分表示注释。  

## 汇编语言的语法是“操作码 操作数”

在汇编语言中，每一行都表示CPU 要执行的一个指令。汇编语言
指令的语法是“操作码 操作数”A（也有一些指令只有操作码，没有操作
数），其中操作码表示指令的动作，操作数表示指令的操作对象。

我们可以使用哪些操作码取决于CPU 的类型。

之前示例中出现的操作码的功能：  
|操作码（含义）|操作数功能|说明|
|---|---|---|
|movl（move）|A,B|将A的值保存到B|
|addl（add）|A,B|将A的值与B的值相加，结果保存到B|
|subl（subtract）|A,B|将A的值与B的值相减，结果保存到B|
|calll（call）|L|调用位于地址L的函数|
|ret（return）|（无）|程序流程返回到函数被调用的位置|

这些操作码都用于32位x86架构CPU。  
操作数可以是数值、内存地址、寄存器名等。  
movl、addl、subl、calll 末尾的l表示long，这代表作为操作对象的数据和地址的长度为32位。  
当操作数有两个时，处理是按照从前往后的顺序进行的。  

本机代码需要加载到内存后运行。  
本机代码中的指令和数据都存放在内存中，当程序运行时，CPU会从内存中读取指令和数据，并将其存入CPU内部的寄存器中进行处理，最后将结果写回内存。  

寄存器是CPU内部的存储空间，但是寄存器的功能并不仅限于存储指令和数据，寄存器还可以参与运算。  

汇编语言源代码中，充当操作数的寄存器名前面会加上%，如%eax、%ebx等。  
内存中的空间是用地址来区分的，而CPU内部的寄存器则是用eax、ebx 这样的名称来区分的。  
不过，CPU内部也有程序员无法直接操作的寄存器，例如表示正、负、溢出等状态的标志寄存器，以及操作系统专用的寄存器等。  

32位x86架构CPU内部的主要寄存器  
|寄存器名|名称|主要功能|
|---|---|---|
|eax|累加器|用于运算|
|ebx|基址寄存器|存放内存地址|
|ecx|计数器|循环次数计数|
|edx|数据寄存器|存放数据|
|esi|源变址寄存器|存放数据转移来源的内存地址|
|edi|目标变址寄存器|存放数据转移目标的内存地址|
|ebp|基址指针寄存器|存放数据存储空间的内存基地址|
|esp|栈指针寄存器|存放栈顶数据的内存地址|

## 最常用的movl指令

用于向寄存器和内存存放数据的movl指令可以说是最常用的指令。  
movl指令有两个操作数，分别表示数据取出和存放的目标位置。  
操作数可以是数值、标签（命名的地址）、寄存器名，我们也可以在它们的左右两边加上圆括号( )来使用。  
当需要直接指定一个数值时，需要在数值的前面加上$符号，例如这里的$456。  

## 将数据存入栈中

程序在运行时会分配一块名为栈的内存空间。  
数据在栈中是从下（编号较大的地址）往上（编号较小的地址）堆积起来，然后从上往下取出的。  
esp寄存器（栈指针寄存器）会记录当前栈顶数据的内存地址。  

栈是临时存放数据的内存空间，函数调用以及局部变量，都会使用栈来存放数据。  

## 函数调用的工作原理

函数调用的汇编语言源代码  

|_MyFunc:|# MyFunc 函数的入口|
|subl $8, %esp|# 将esp的值减8|
|movl $456, 4(%esp)|# 将456存入esp+4地址|
|movl $123, (%esp)|# 将123存入esp地址|
|calll _AddNum|# 调用_AddNum|
|addl $8, %esp|# 将esp的值加8|
|ret|# 返回函数被调用的位置|

subl $8, %esp 表示将esp寄存器的值减8，也就是在栈中分配一块长度为8字节的内存空间。  
执行call指令时，指向call指令的下一条指令的内存地址（也就是函数返回的目标地址）会被自动保存到栈中，esp寄存器的值也会随之更新。  
这里，call指令的下一条指令是addl $8, %esp，因此这条指令的内存地址会被保存到栈中。读取这个内存地址，程序就可以从被调用的函数返回到addl $8, %esp 位置继续执行。  

## 被调用函数的工作原理

被调用函数的汇编语言源代码  

|_AddNum:|# AddNum 函数入口|
|movl 8(%esp), %eax|# 将esp+8 地址处的值存入eax|
|addl 4(%esp), %eax|# 将esp+4 地址处的值累加到eax|
|ret|# 返回函数被调用的位置|

## 全局变量和局部变量的工作原理  

C语言中的变量分为两种，在函数外部声明的变量称为全局变量，在函数内部声明的变量称为局部变量。
  - 全局变量（global variable）可以在程序的所有函数中访问;
  - 局部变量（local variable）只能在声明它的函数中访问。

用于分析局部变量和全局变量原理的C语言程序:  

---
// 全局变量声明
int x = 123;
int y = 456;
// 使用全局变量和局部变量的函数
int MyFunc() {
int a;
a = x + y;
return a;
}
---
变量x和变量y是在函数外部声明的，因此它们是全局变量，并且分别被设定了初始值123和456。  
MyFunc函数中声明了变量a，它是一个局部变量。这里，我们将变量x和变量y相加的结果赋值给变量a，并将其作为返回值返回。  

在命令提示符中输入以下命令并按下回车键来编译这段程序。  
bcc32c -c -Od -S list10_5.c  
之前我们为了避免编译器生成冗余代码而指定了“-O1”选项，这里我们指定“-Od” A （大写字母O 和小写字母d）来让编译器生成冗余代码。
  - 之所以这么做，是因为如果不生成冗余代码，有些使用到局部变量的程序逻辑会被编译器删除。

代码清单转换成汇编语言的结果（节选）  

|||
|---|---|
|    .section _TEXT,"xr"|# 指令段开始 ————————————————（1）|
|_MyFunc:|# MyFunc函数的入口 ————————————（2）|
|    pushl %ebp|# 将ebp的值暂存到栈|
|    movl %esp, %ebp|# 将esp的值存入ebp ———————————（3）|
|    pushl %eax|# 将eax的值暂存到栈|
|    movl _x, %eax|# 将_x的值存入eax ————————————（4）|
|    addl _y, %eax|# 将_y的值累加到eax ———————————（5）|
|    movl %eax, -4(%ebp)|# 将eax的值存入ebp-4 地址 ————————（6）|
|    movl -4(%ebp), %eax|# 将ebp-4地址的值存入eax|
|    addl $4, %esp|# 将esp加4|
|    popl %ebp|# 从栈中恢复ebp的值|
|    ret|# 返回函数被调用的位置 ———————————（7）|
|||
|    .section _DATA,"w"|# 数据段开始 ————————————————（8）|
|_x:|# 全局变量x的标签 —————————————（9）|
|    .long 123|# 全局变量x的值|
|_y:|# 全局变量y的标签 —————————————（10）|
|    .long 456|# 全局变量y的值|

本章前半部分讲过，编译后的程序会被分成段。在上面的程序中，我们可以看到一个存放指令的段和一个存放数据的段。  
(1) 处的.section_TEXT, "xr" 后面的部分是指令段；
(8) 处的.section _DATA, "w" 后面的部分是数据段。
  - 存放数据的段被命名为_DATA，属性为"w"，所以是可写的。
  - 数据段中的(9)和(10)分别是_x:和_y:两个标签，它们代表全局变量x和y；
  - 变量名前面有一个下划线（_）是BCC32编译器的规定；
  - .long 123和.long 456是两条伪指令，表示在这个位置上存放两个32位的值123和456。
  - 伪指令是面向汇编器的指示，所以汇编器会在生成本机代码时将123和456这两个值附加在程序后面。

通过上述讲解，我们可以发现全局变量就是事先附加在程序数据段的数据。  
当程序运行时，指令段和数据段会被一起加载到内存中，并在程序运行过程中一直驻留内存，因此程序中所有的函数都可以访问全局变量。  
相对地，局部变量则是在调用函数时，由函数的代码临时存入栈中的。  

## 循环的工作原理

通过分析汇编语言源代码，看一看C语言中的for循环和if条件分支在计算机内部是如何实现的。  
在循环和条件分支的实现上，尚未介绍的比较指令和转跳转指令发挥了很大的作用。  

以下是一段执行10次循环的C语言程序，其中局部变量i为循环变量。for语句的循环体中调用了一个不执行任何操作的空函数MySub()。  
  - 用于计算循环执行次数的变量称为循环计数变量（loop counter），简称循环变量。
---
// MySub函数的定义  
void MySub()  
{  
    // 不执行任何操作      
}  

// MyFunc 函数的定义  
void MyFunc()  
{  
   int i;  
   for (i = 0; i < 10; i++)  
   {  
       // 循环调用10 次MySub 函数  
       MySub();  
   }  
}  

将代码另存为list10_7.c文件，然后在命令提示符中输入以下命令并按下回车键。在这里我们依然指定了用于生成冗余代码的“-Od”选项。  
bcc32c -c -Od -S list10_7.c  
编译后会生成汇编语言源代码，将for循环对应的代码提出来，并为每一行添加注释，结果如下所示。  

在C语言的for语句中，圆括号中的3个表达式分别表示循环变量初始化（i = 0）、循环执行条件（i < 10）以及循环变量更新（i + + ），花括号（{ }）中的部分为循环实际执行的操作（循环体）。  
与之相对，在汇编语言源代码中，循环是通过比较指令和跳转指令来实现的。  

---
代码转换成汇编语言的结果（节选）

```asm
    movl    $0, -4(%ebp)     # 将0存入循环变量 ————————————————————（1）  
LBB1_1:                      # 表示循环体入口的标签 ————————————————（2）  
    cmpl    $10, -4(%ebp)    # 将10与循环变量的值进行比较 ——————————（3）  
    jge     LBB1_4           # 若10≤循环变量的值则跳转到LBB1_4 ————（4）  
    calll   _MySub           # 调用MySub函数 —————————————————————（5）  
    movl    -4(%ebp), %eax   # 将循环变量的值存入eax寄存器 —————————（6）  
    addl    $1, %eax         # 将eax寄存器的值加1 —————————————————（7）  
    movl    %eax, -4(%ebp)   # 将eax寄存器的值存入循环变量 —————————（8）  
    jmp     LBB1_1           # 无条件跳转到LBB1_1 —————————————————（9）  
LBB1_4:                      # 表示循环结束的标签 ——————————————————（10）  

---

代码中出现了之前没介绍过的操作码：

|操作码（含义）|操作数|功能|
|---|---|---|
|cmpl（compare）|A, B|比较A与B|
|jge（jump greater or equal）|L|如果A≤B则跳转到L|
|jle（jump less or equal）|L|如果A≥B则跳转到L|
|jmp（jump）|L|无条件跳转到L|
|ret（return）|（无）|程序流程返回函数被调用的位置|

> 操作码末尾的l=long，表示作为操作对象的数据和地址的长度为32 位。

将之前代码中的流程用C语言描述：  

i = 0;              // 将0赋值给循环变量  
LBB1_1:             // 循环入口标签  
if (10 <= i)        // 判断10≤i 是否成立  
{  
    goto LBB1_4;    // 判断结果为真则跳转到LBB1_4  
}  
MySub();            // 调用MySub函数  
i++;                // 将循环变量的值加1  
goto LBB1_1;        // 无条件跳转到LBB1_1  
LBB1_4:             // 表示循环结束的标签  

## 条件分支的工作原理

C语言的条件分支是通过if语句来描述的。  
C语言的if语句会检查圆括号中的条件，如果条件为真则执行if块A中的语句，否则执行else块中的语句。  
与之相对，汇编语言源代码中的条件分支则是通过比较指令和跳转指令来实现的。  

# 访问硬件的方法

## 热身问答

1. 汇编语言中用于外部设备输入输出的指令是in指令和out指令。
   - 在用于x86架构CPU的汇编语言中，用in指令进行I/O输入，用out指令进行I/O输出。
   
2. I/O的全称是Input/Output（输入/输出）。
   - 负责在计算机主机与外部设备之间进行输入输出的芯片称为I/O控制器，简称I/O。
   
3. 用于区分外部设备的编号叫I/O地址或I/O端口号。
   - 为了区分连接到计算机上的不同外部设备，每个设备会被分配一个I/O地址。
   
4. IRQ的全称是Interrupt Request（中断请求）。
   - IRQ是指用于区分发出中断请求的外部设备的编号。
     - IRQ 编号 = 中断请求线的编号，这是一种“用名字代指编号”的语言简化现象。
     
5. DMA的全称是Direct Memory Access（直接内存访问）。
   - DMA是指外部设备不经过CPU中转，直接与计算机内存传输数据。
   
6. 用于区分使用DMA的外部设备的编号叫DMA通道（DMA channel）。
   - 网络、磁盘等数据量大的外部设备会使用DMA，不同设备会通过DMA通道来进行区分。

## 应用程序是否与硬件有关

在使用C语言等高级编程语言编写Windows应用程序时，很少会见到直接访问硬件的指令。这是因为对硬件的访问已经由Window操作系统一手包办了。  
然而，操作系统还是为应用程序提供了间接访问硬件的方法，那就是使用系统调用。在Windows中，系统调用也被称为API。  
每个API都是一个能够被应用程序调用的函数，这些函数的本体位于DLL文件中。  

Windows本身也是一种程序（软件），因此Windows是向CPU发出了某种指令，从而通过程序实现了对硬件的访问的。

## 负责硬件输入输出的in指令和out指令

Windows使用输入输出指令来对硬件进行访问，其中最具代表性的两个指令就是in和out。  
这两个指令都是汇编语言的助记符，但应用程序并不能直接使用in和out指令，因为Windows禁止应用程序直接访问硬件。  
  - in指令可以从指定编号的端口输入数据，并将其存入CPU内部的寄存器。
  - out指令可以将CPU寄存器中的数据输出到指定编号的端口。

计算机主机上有用于连接显示器、键盘等外部设备的接口，这些接口内部都装有用于对主机和外部设备的电信号进行相互转换的芯片，这些芯片统称为I/O控制器（简称为I/O）。  
由于数据格式和电压不同，所以计算机主机并不能和外部设备直接相连，为此我们需要使用I/O控制器。  

I/O是Input/Output（输入/ 输出）的缩写，显示器、键盘等设备都有专用的I/O控制器。I/O控制器中有用于临时存放输入输出数据的存储器，这种存储器被称为端口。  
I/O控制器内部的存储器有时也被称为寄存器，但这种寄存器和CPU内部的寄存器功能不同。  
CPU内部的寄存器可以参与运算，但I/O控制器内部的寄存器基本上只能用来临时存放数据。  

I/O控制器芯片中有多个端口。计算机可以连接多个外部设备，于是就有多个I/O控制器，也就有多个端口。  
一个I/O控制器可以控制一个外部设备，也可以控制多个外部设备，因此我们就需要用端口号来区分不同的端口。端口号也被称为I/O地址。  
in指令和out指令通过端口号可以在指定端口和CPU之间输入和输出数据，这与通过内存地址来读写内存是一样的。  

## 外部设备的中断请求

IRQ是一种让当前正在运行的程序暂停，转而运行其他程序的机制，这被称为中断处理。  
中断处理在硬件控制中扮演着重要的角色。如果没有中断处理，有些任务就无法顺利进行。  

在进行中断处理时，被中断的程序（主程序）会暂停运行，直到中断处理程序运行完毕。  

发出中断请求的是连接外部设备的I/O控制器，运行中断处理程序的是CPU。  
要识别具体是哪个设备发出的中断请求，我们需要使用名为中断号的编号，而不是端口号。  
设备管理器属性的IRQ项目中显示的0xFFFFFFF7(-9)，就表示由显示器发出的中断请求编号为0xFFFFFFF7(-9)。  

除了显示器，其他各种设备也会发出中断请求，因此需要对每个设备都分配一个中断号。  

如果多个外部设备同时发出中断请求，CPU就会陷入混乱。因此在I/O控制器和CPU之间还有一个中断控制器进行协调。中断控制器会将来自多个外部设备的中断请求依次交给CPU来处理。  

CPU 接受来自中断控制器的中断请求之后，会从当前运行的主程序切换到中断处理程序。  
中断处理程序的流程：  
1. 将CPU中所有寄存器的值都暂存到内存的栈空间中；
2. 中断处理程序与外部设备之间进行输入输出操作；
3. 最后将暂存到栈中的值恢复到寄存器中，继续运行主程序。

如果不将CPU寄存器的值恢复到中断处理之前的状态，主程序的运行就会受到影响，在最坏的情况下程序会卡死或者出现混乱，导致系统崩溃。  
在主程序运行过程中，一定会出于某种目的使用CPU内的寄存器。  
如果这时突然切换到另一个程序，在中断处理结束后所有寄存器的值就必须恢复到中断前的状态，因为只要寄存器的值没变，主程序就可以像什么事都没有发生过一样继续运行。  

## 通过中断实现实时处理

几乎所有的外部设备都会频繁地发出中断请求，这是因为外部设备输入的数据需要实时进行处理。  
当然，不使用中断也可以从外部设备输入数据，但在这种情况下主程序就需要不断查询外部设备有没有要输入的数据。  

外部设备的数量很多，因此需要依次查询。依次查询多个外部设备状态的操作称为轮询（polling）。  
轮询适用于那些不频繁产生中断的系统，但不适用于个人计算机。  
如果在查询鼠标有没有输入数据的时候按下了键盘会怎样呢？输入的字符就无法实时显示在屏幕上了。  
实际上，使用中断来处理键盘输入，就可以将输入的字符实时显示在屏幕上了。  

像打印机等专门用来输出的外部设备，也会通过中断来通知计算机自己是否处于可以接收数据的状态。  
外部设备的数据处理速度要远远慢于计算机主机的处理速度。  
如果仅当CPU收到中断请求时才发送数据，主程序就不必一直去查询设备的状态，CPU就可以有更多的时间来运行其他程序了。  

## 能够快速传输大量数据的DMA

DMA是指外部设备不经过CPU中转，直接和内存进行数据传输，常用于网络、磁盘等设备。  
使用DMA可以将大量数据快速传输到内存中，它能够节省CPU 中转所需的时间，而且还可以避免高速的CPU等待低速的外部设备，从而提高其他任务的处理效率。  

DMA是通过名为DMA控制器（DMA Controller，DMAC）的芯片实现的。  
DMA控制器中有多个用于进行DMA的窗口，这些窗口通过名为DMA通道的编号来进行区分，进行DMA的外部设备也是通过分配给它们的DMA通道来进行区分的。  

与DMA相对，通过CPU在外部设备和内存之间传输数据的方式称为PIO（Programmed I/O）。  

I/O端口号、IRQ和DMA通道可以说是识别外部设备的“三件套”。但是，IRQ和DMA通道并不是每个外部设备都必备的。  
计算机主机通过软件访问硬件所必需的信息其实只有I/O端口号。  
只有需要进行中断处理的外部设备才需要IRQ，只有需要进行DMA的外部设备才需要DMA通道。  
如果多个设备被设置为同一个I/O端口号、IRQ或DMA 通道，计算机就无法正常工作。  
出现这种情况时，设备管理器中就会出现“设备冲突”的提示，这里的冲突就是使用了相同编号的意思。  

## 显示字符和图像的原理

简单来说，计算机中有一个用于保存要显示的信息的存储器，这一存储器称为显存（Video RAM，VRAM）。  
程序只要将数据写入显存，数据就可以在显示器上显示出来。  

在曾经的MS-DOS时代，显存就是内存（主存储器）的一部分。  
例如，当时的PC-9801型计算机，其内存地址A0000以后的空间是作为显存使用的。  
程序将数据写入显存所对应的地址，就可以显示出字符和图像。  
但是，当时能显示的字符和图像最多只有16色，这是因为显存的容量较小。  

现在的PC一般配有名为显卡的专用硬件，显卡上装有独立于内存的显存和专用的图像处理器GPU（Graphics Processing Unit，图形处理器）。  
在Windows中，绘制色彩丰富的图像是家常便饭的事，因此需要数GB的显存。此外，为了提高图像显示的速度，还需要专用的处理器。  
但是，将显存中的数据显示出来这一基本原理没有改变。  

在计算机世界中，新的技术不断涌现，但计算机所能完成的工作，无非是从外部设备输入数据，将数据存入内存，用CPU进行运算，然后将数据输出到外部设备，这些东西从未改变。  
程序的内容究其根本也只是数据的输入、存储、运算和输出而已。  

# 如何让计算机“学习”

## 热身问答

1. 机器学习（Machine Learning，ML）：在机器学习中，我们使用学习程序让计算机读取大量数据并根据数据特征自己进行学习。

2. 分类问题是机器学习的主题之一，即对数据进行正确的识别和分类。
   - 本章中，笔者会介绍手写数字识别这个分类问题的实例。
     - 具体来说就是对手写数字图像数据进行识别，并将其分类为数字0～9。
     
3. SVM是一种机器学习算法，它的全称是支持向量机（Support Vector Machine）。
   - 本章中，针对手写数字识别问题，我们会使用支持向量机算法。
   
4. 为什么在机器学习领域经常使用Python？
   - 因为Python 提供了很多机器学习相关的库，我们可以通过解释器方便地使用这些功能。
     - 本章中，我们会使用scikit-learn 这个机器学习库，只需要几行代码就可以体验机器学习。
     
5. 在分类问题的机器学习中，我们将学习算法称为学习器，将作为学习结果得到的模型称为分类器。模型就是用于识别的机制。学习器和分类器的本质都是程序。

6. 机器学习中的cross validation中文叫交叉验证。
   - 交叉验证是一种不断轮换编写学习器所使用的训练数据和分类器所使用的测试数据来进行机器学习的方法。
     - 由此，我们可以检验学习模型的识别率是否存在因学习数据的类型而出现偏差的情况。

## 什么是机器学习

机器学习指的是让计算机这种机器来学习。  
假设我们要让计算机识别手写数字0～9。如果用于识别的程序都由人来编写，那就不是机器学习了。  
在机器学习中，程序员只编写用于学习的程序，这个程序的内容是让计算机读取大量数据，然后学习这些数据的特征，并生成一个识别模型。  
这里，模型指的是识别机制。  

机器学习有很多不同的方法， 这里要介绍的是有监督学习（supervised learning）。有监督学习就是给计算机提供大量带正确答案的数据。  
以识别手写数字为例，我们可以给计算机提供大量手写数字的图片，并为每张图片配上它所代表的0～9 中的正确数字。  
这里的正确答案就充当了“监督者”的角色。有监督学习适用于手写数字识别这样的分类问题领域。  

分类问题中有监督学习的步骤：
1. 将学习数据和答案数据划分为训练数据和测试数据；
2. 用学习算法（学习器）学习训练数据并生成模型（分类器）；
3. 用测试数据评估模型的性能。
   - 如果评估结果显示分类器的识别率达到了一定的水平，那么这个分类器就可以用来对新数据（没有正确答案的数据）进行识别了。

## 支持向量机

支持向量机，它是一种适用于分类问题的有监督学习算法。  
定义是找一个最优的分界线，把不同类别的数据尽可能清晰地分开，并且让最近的数据点到这条线的距离最大（即“间隔最大化”）。  
距离边界线最近的数据点是支持向量。  

数据分类的数量称为分类（class）数。  
  - 在猫狗识别的例子中，分类数为2（猫、狗）。
一个数据所拥有的用于分类的信息称为特征量，特征量的数量称为维数。  
  - 在猫狗识别的例子中，特征量的维数为2（好养度、亲人度）。
只要增加图上坐标轴的数量以及代表边界线的表达式项数，支持向量机就可以解决分类数和维数较大的问题。  

## Python交互模式的使用方法

机器学习中经常会使用编程语言Python，原因是
1. Python中提供了包含各种机器学习相关功能的库；
2. Python是一种基于解释器的语言。
   - 这意味着我们可以用简短的程序来试验这些库的功能。

> 程序运行方式可分为编译型和解释型两种。  
  在编译型语言中，编译器会将源文件一次性编译成可执行文件，然后运行可执行文件。  
  在解释型语言中，解释器会逐行解释和运行源文件中的内容。  

Python运行程序的方法分为两种。  
一种是用Python解释器对事先编写好的源代码进行解释执行的脚本模式（script mode）；  
另一种是直接启动Python解释器，通过键盘逐行输入程序并解释执行的交互模式（interactive mode）。  

交互模式的使用方法：
1. 在Windows中安装Anaconda后，“开始”菜单中会出现一个“Anaconda3 (64bit)”文件夹。
2. 点击运行该文件夹中的“Anaconda Prompt (anaconda3)”，该程序会弹出一个命令提示符窗口；
3. 这时用键盘输入python并按下回车键，就会启动Python解释器，屏幕上会显示>>>提示符（提示用户输入的字符串）。

在交互模式中，输入程序并按下回车键后，程序就会被立即执行。  
在Python中，有一个用于在屏幕上显示数据的print函数。  
但是在交互模式中，我们不需要使用print函数，只要直接输入变量名并按下回车键，就可以让变量的值显示出来，输入函数名并按下回车键就可以显示函数的返回值。  

Python中可供程序使用的各种功能都以函数或对象的形式来提供。  
函数一般提供单一功能，对象一般提供复合功能。使用对象功能的语法是“对象名. 功能名”。  

Python标准的内置函数和对象是可以直接使用的，但机器学习中使用的特殊函数和对象，需要通过import命令导入后使用。  
导入在Python中就是“使用非标准功能”的意思。  
模块就是包含多个函数和对象的文件。  

要退出Python解释器，需要在>>> 提示符后面输入exit() 并按下回车键。exit是内置函数。  

## 准备学习数据

以识别手写数字为主题，实际体验一下机器学习。  

在机器学习中，我们需要学习数据和学习器。  
这里使用Anaconda自带的scikit-learn库所提供的学习数据和学习器。  
除scikit-learn之外，我们还使用了用于绘制可视化图表的matplotlib 库，这个库也是Anaconda自带的。  

首先来确认一下scikit-learn提供的手写数字学习数据包含哪些字段。  
学习数据的量不大，不具备实用价值，只能当玩具来用，因此被称为“玩具数据集”（toy dataset），但是对体验机器学习来说已经足够了。  

使用Python交互模式运行代码确认手写数字学习数据中的字段：  
\>\>\> from sklearn import datasets ————————————————————（1）  
\>\>\> digits = datasets.load_digits() ——————————————————（2）  
\>\>\> dir(digits) ——————————————————————————————————————（3）  
['DESCR', 'data', 'feature_names', 'frame', 'images', 'target',  
'target_names']  

(1) 处从sklearn模块导入了datasets对象；
(2) 处使用datasets对象中的load_digits方法，将手写数字的数据集加载到内存，并赋值给变量digits；
      - 方法指的是对象所具有的功能。
(3) 处使用Python内置的dir函数提取出变量digits的数据集中所包含的字段。
      - 显示结果中的DESCR、data等就是字段的名称。

DESCR是数据集的描述（description）。  
data是手写数字的图像数据。  
images是将手写数字图像数据按8行8列格式化后的数据。  
target是手写数字的答案数据。  
target_names是答案数据的含义（这里是数字0～9）。  

在识别手写数字时，需要将图像数据分成0～9，共10个类别，因此分类数为10。  
每个数字的图像数据有8×8=64个信息，因此特征量的维数为64。  
每个特征量都是字符中的一个像素点，其浓淡以数值0～16来表示。  
手写数字的数据一共有1797条，我们可以通过数据名[0]～数据名[1796]的格式访问其中每条数据。  
  - Python中第1条数据的编号为0，因此1797条数据的编号是0～1796。

## 查看手写数字数据的内容

在Python的交互模式中输入以下代码中的程序并运行。这里我们随便选一条数据来显示，比如编号为1234的数据。  

\>\>\> from sklearn import datasets —————————————————————————（1）  
\>\>\> digits = datasets.load_digits() ————————————————————————（2）  
\>\>\> digits.data[1234] ————————————————————————————————（3）  
array([ 0., 1., 12., 16., 14., 8., 0., 0., 0., 4., 16., 8., 10.,  
        15., 3., 0., 0., 0., 0., 0., 5., 16., 3., 0., 0., 0.,          
        0., 1., 12., 15., 0., 0., 0., 0., 0., 10., 16., 5., 0.,   
        0., 0., 0., 5., 16., 10., 0., 0., 0., 0., 1., 14., 15.,  
        6., 10., 11., 0., 0., 0., 13., 16., 16., 14., 8., 1.])  
\>\>\> digits.images[1234] ———————————————————————————————（4）  
array([[ 0., 1., 12., 16., 14., 8., 0., 0.],  
       [ 0., 4., 16., 8., 10., 15., 3., 0.],         
       [ 0., 0., 0., 0., 5., 16., 3., 0.],         
       [ 0., 0., 0., 1., 12., 15., 0., 0.],         
       [ 0., 0., 0., 10., 16., 5., 0., 0.],         
       [ 0., 0., 5., 16., 10., 0., 0., 0.],         
       [ 0., 1., 14., 15., 6., 10., 11., 0.],         
       [ 0., 0., 13., 16., 16., 14., 8., 1.]])         
\>\>\> digits.target[1234] ———————————————————————————————（5）  
2  

(3) 处的digits.data[1234]的运行结果就是显示64个数值，它们代表一个数字的图像数据（64维特征量）。  
(4) 处的digits.images[1234]的运行结果就是将表示一个数字的图像数据以8行×8列的格式显示出来。  
(5) 处的digits.target[1234]的运行结果就是显示这个数字的正确答案。这里显示的结果为2，表示数字为2。  

---

我们可以使用matplotlib库将手写数字的数据以可视化的形式显示出来。  

\>\>\> from sklearn import datasets ————————————————————（1）  
\>\>\> digits = datasets.load_digits() ——————————————————（2）  
\>\>\> import matplotlib.pyplot as plt ——————————————————（3）  
\>\>\> plt.imshow(digits.images[1234], cmap="Greys") —————————（4）  
<matplotlib.image.AxesImage object at 0x00000290C7707190>  
\>\>\> plt.show() ——————————————————————————————（5）  

(3) 处从matplotlib模块中导入pyplot对象，并给它设置了较短的别名plt；
    - 这是一个绘图用途的功能，设置别名是为了减少重复输入，提高效率。
    - 而且在python社区中，plt作为别名已经成了标准习惯。  
(4) 处将digits.images[1234] 的内容以灰度形式绘制出来； 
    - 灰度（grayscale）是指将图像数据的值用对应深浅的灰色来替换。 
(5) 处将绘制好的图像显示出来。  

运行这个程序之后，窗口中会显示出图像。  

## 通过机器学习识别手写数字

> 刚才我们已经确认了手写数字数据集的内容，下面就来体验一下机器学习吧。这里我们将1797条手写数字数据的三分之二用作训练数据，剩下的三分之一用作测试数据。

机器学习的步骤  
1. 将学习数据和答案数据划分为训练数据和测试数据；
2. 用学习算法学习训练数据并生成模型；
3. 用测试数据评估模型的性能。

这些步骤，每个步骤只需要几行程序就可以实现。  

在Python的交互模式中运行代码：通过机器学习识别手写数字

\>\>\> from sklearn import datasets ———————————————————————————— （1）  
\>\>\> digits = datasets.load_digits() ——————————————————————————（2）  
\>\>\> from sklearn.model_selection import train_test_split ————— （3）  
\>\>\> d_train, d_test, t_train, t_test = \ ————————————————————— （4）  
... train_test_split(digits.data, digits.target, train_size=2/3)  
\>\>\> from sklearn import svm —————————————————————————————————— （5）  
\>\>\> clf = svm.SVC() —————————————————————————————————————————— （6）  
\>\>\> clf.fit(d_train, t_train) ———————————————————————————————— （7）  
SVC()  
\>\>\> clf.score(d_test, t_test) ———————————————————————————————— （8）  
0.9803600654664485  

(3) 处从sklearn.model_selection 模块中导入train_test_split 函数。  
(4) 处的d_train, d_test, t_train, t_test = train_test_split(digits.data, digits.target, train_size = 2/3) 是一行语句，因为太长我们在中间进行了换行。  
在一行程序的末尾输入一个“\”字符就可以实现换行，换行后下一行的开头会显示“...”。  

train_test_split(digits.data, digits.target, train_size = 2/3) 表示将手写数字图像数据digits.data 和答案数据digits.target 按照2/3 的比例（train_size = 2/3）随机分割出一部分生成训练数据。  
随机分割后的数据会依次赋值给左边的d_train、d_test、t_train、t_test 变量。  

将数据集分割为训练数据和测试数据：  
|数据集|训练数据（2/3）|测试数据（1/3）|
|---|---|---|
|学习数据（digits.data）|d_train|d_test|
|答案数据（digits.target）|t_train|t_test|

(5) 处从sklearn 模块中导入了svm 对象（svm 代表support vector machine，也就是支持向量机）。svm 对象提供了支持向量机相关的各种功能。  
(6) 处使用svm 对象的SVC 方法（SVC = SVM Classification，用支持向量机分类）来生成学习器对象， 并将其命名为clf（clf =classifier，分类器的意思）。  
(7) 处以训练数据d_train 和t_train 为参数，调用学习器对象的fit方法，这样计算机就会进行机器学习并生成模型（分类器）。学习得到的模型保存在学习器对象内部。  
(8) 处以测试数据d_test 和t_test 为参数，调用学习器对象的score方法。  
由此对学习得到的模型进行性能评估，得到模型的识别率（测试数据中识别正确的百分比）。运行后的结果显示识别率为0.980 360 065 466 448 5（约98%）。  
由于训练数据和测试数据是随机分割的，所以每次运行程序所得到的识别率会有所不同。  

## 尝试交叉验证

交叉验证是一种不断轮换训练数据和测试数据来进行机器学习的方法。  
由此，我们可以检验学习模型的识别率是否存在因学习数据的类型而出现偏差的情况。  

Python交互模式中运行进行交叉验证的代码：

\>\>\> from sklearn import datasets —————————————————————————————— （1）  
\>\>\> digits = datasets.load_digits() ——————————————————————————— （2）  
\>\>\> from sklearn import svm ——————————————————————————————————— （3）  
\>\>\> clf = svm.SVC() ——————————————————————————————————————————— （4）  
\>\>\> from sklearn.model_selection import cross_val_score ——————— （5）  
\>\>\> cross_val_score(clf, digits.data, digits.target, cv=3) ———— （6）  
array([0.96494157, 0.97996661, 0.96494157])  

(5) 处从sklearn.model_selection 模块导入了cross_val_score 函数。  
(6) 处使用cross_val_score 函数进行三轮交叉验证。  
cross_val_score函数的参数分别为学习器clf、手写数字图像数据digits.data、答案数据digits.target，cv = 3 表示交叉验证的轮数（数据分割的份数）。  

程序显示的运行结果为0.964 941 57、0.979 966 61、0.964 941 57，这表示三轮交叉验证得到的识别率分别约为96%、98%、96%。  
我们可以认为不存在因学习数据类型而出现较大偏差的情况。  