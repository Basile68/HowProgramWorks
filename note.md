# CPU

## 热身问答

1. 程序是指示计算机每一步行动的一组指令；
2. 程序是由指令和数据构成的；
3. 机器语言是 CPU 可以直接识别并使用的语言；
     - 使用 C、Java 等语言编写的程序最后都会转化成机器语言。
4. 正在运行的程序存储在内存；
     - 硬盘和磁盘等媒介上保存的程序被复制到内存后才能运行。
5. 内存地址是内存中用来表示命令和数据存储位置的数值；
     - 地址是由整数值表示。
        - 计算机的内存（RAM）是由许多存储单元组成的，每个存储单元都有一个唯一的编号，这个编号就叫 内存地址。
6. 计算机的构成元件中， 负责程序的解释和运行的是CPU。

## CPU 的内部结构解析

CPU 和内存是由许多晶体管组成的电子部件， 通常称为 IC (lntegrated Circuit, 集成电路）构成的。  

从功能方面来看，CPU的内部由四个部分构成， 各部分之间由电流信号相互连通。
1. 寄存器；
   - 寄存器可用来暂存指令、数据等处理对象， 可以将其看作是内存的一种。
2. 控制器；
   - 控制器负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。
3. 运算器；
   - 运算器负责运算从内存读入寄存器的数据。
4. 时钟。
   - 时钟负责发出 CPU 开始计时的时钟信号。
   
> 有些计算机的时钟位于CPU的外部
   - 说明计算机系统中的“时钟信号”（Clock Signal）不是由CPU内部产生的，而是由主板或其他外部电路提供给CPU的。

> 程序运行流程示例：
  1. 程序员用C语言等高级语言编写程序；
  2. 将程序编译后转换成机器语言的 EXE 文件；
  3. 程序运行时，在内存中生成 EXE 文件的副本；
     - 因为 CPU 只能直接从内存（RAM）中读取和执行指令，而不能直接从硬盘上运行程序。
  4. CPU 解释并执行程序内容。

> 通常所说的内存指的是计算机的主存储器（main memory），简称主存。
  主存通过控制芯片等与 CPU 相连，主要负责存储指令和数据。
  需要注意的是，主存中存储的指令和数据会随着计算机的关机而自动清除。
  
## CPU 是寄存器的集合体

CPU 的构成部分中，程序员只需要了解寄存器即可，因为程序是把寄存器作为对象来描述的，其余部分都不用太过关注。  

> 通常我们将汇编语言编写的程序转化成机器语言的过程称为汇编；反之，机器语言程序转化成汇编语言程序的过程则称为反汇编。
  机器语言指令的本质是电子信号，我们用英语单词或其缩写（称为助记符）表示每一种信号的功能，就构成了汇编语言。
  汇编语言和机器语言基本上是一一对应的，这一点和C语言、Java等高级编程语言有很大差别。
  
通过阅读汇编语言编写的代码，能够了解转化成机器语言的程序的运行情况。机器语言级别的程序时通过寄存器来处理（即存储）的。
  - 也就是说，在程序员看来，“CPU 是寄存器的集合体”。

对于程序员来说，CPU 时具有各种功能的寄存器的集合体。
  - 其中，程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其他的寄存器一般由多个。
  - 程序计数器和标志寄存器比较特殊。

> 内存中存储数据的位置是用地址来区分的，寄存器则是用名称来区分的。
  
|种类|功能|
|---|---|
|累加寄存器（accumulator register）（第三版中改称累加器）|存储执行运算的数据和运算后的数据|
|标志寄存器（flag register）|存储运算处理后的 CPU 状态|
|程序计数器（program counter）|存储下一条指令所在内存的地址|
|基址寄存器（base register）|存储数据内存的起始地址|
|变址寄存器（index register）|存储基址寄存器的相对地址|
|通用寄存器（general purpose register）|存储任意数据|
|指令寄存器（instruction register）|存储指令。CPU 内部使用，程序员无法通过程序对该寄存器进行读写操作|
|栈寄存器（stack register）|存储栈区域的起始地址|

## CPU 解释并执行程序的过程（个人理解

1. 由操作系统在加载程序时，根据“入口点”设置程序计数器里的指令地址；
2. 控制器根据 PC 提供的地址，向内存发起读取指令；
3. 内存获取读取指令后向控制器返回对应地址中存储的指令内容；
4. 控制器进行译码分析指令类型并执行，即指挥 ALU/寄存器/内存完成操作；
5. 更新 PC 中的值；
6. 回到第二步，继续下一条指令。

## 条件分支和循环机制

程序的流程分为顺序执行、条件分支和循环三种。
  - 顺序执行是指按照地址内容的顺序执行指令；
    - 顺序执行中，每执行一个指令程序计数器的值就会自动递增以指向内存中下一条连续的指令。
  - 条件分支是指根据条件执行任意地址的指令；
  - 循环是指重复执行同一地址的指令。

> 条件分支和循环中使用的跳转指令，会参照当前执行的运算结果来判断是否跳转。
  - 标志寄存器的数值会根据运算结果自动设定，条件分支在跳转指令前会进行比较运算；
    - 至于是否执行跳转指令，则由 CPU 在参考标志寄存器的数值后进行判断。
      
## 函数的调用机制

1. 函数调用时使用call指令，而不是跳转指令；
2. call指令会把调用函数后要执行的指令地址存储在程序的栈区域内；
3. 然后将函数的入口地址设定到程序计数器；
4. 函数处理完毕后，再通过函数的出口来执行return指令；
    - return 指令的功能是把保存在栈中的地址设定到程序计数器中。

## 用基址和变址实现数组

通过基址寄存器和变址寄存器可以对主内存上特定的内存区域进行划分，按照数组的方式对其进行使用。

例如查看10000000地址~1000FFFF地址时，
   - 可以将10000000存入基址寄存器，并使变址寄存器的值在00000000~0000FFFF变化；
   - CPU 则会把基址寄存器+变址寄存器的值解释为实际查看的内存地址。

> 变址寄存器的值就相当于高级编程语言程序中数组的索引功能。

> 机器语言指令的主要类型和功能

|类型|功能|
|---|---|
|数据传送指令|寄存器和内存、内存和内存、寄存器和外部设备之间的数据读取操作|
|运算指令|用累加器执行算术运算、逻辑运算、比较运算和移位运算等操作|
|跳转指令|实现条件分支、循环、无条件跳转|
|call/return指令（调用/返回指令）|函数的调用/返回调用前的地址|

# 数据是用二进制数表示的

## 热身问答

8位=1字节，32位就是4字节；
  - “位”是数据最小单位（0 或 1），“字节”是计算机处理数据的基本单位，1 字节 = 8 个位。
反转部分图形模式时， 使用的是什么逻辑运算？
  - XOR 运算只反转与1相对应的位。NOT运算时反转所有的位。

## 用二进制数表示计算机信息的原因

计算机内部是由 IC 这种电子部件构成的，IC 上的所有引脚都只有直流电压 0V 或 5V 两个状态。也就是说 IC 的一个引脚，只能表示两个状态。  
IC 的这个特性，决定了计算机的信息数据只能用二进制数来处理。尽管二进制并不是为 IC 发明的计数法，但在用电子信号表示信息时，使用二进制时非常合适的。  
计算机处理信息的最小单位时比特，它相当于1位二进制数。比特的英文bit时binary digit（二进制数）的缩写。
  - 比特和位代表的意义没有区别，只是翻译问题导致的两种不同称呼。

> 二进制数的位数一般是8位、16位、32位......也就是8的倍数，这是因为计算机所处理的信息的基本单位是8位二进制数。  

内存和磁盘都使用字节单位来存储和读写数据，使用位单位则无法读写数据，因此字节是信息的基本单位。  
  - 用字节单位处理数据时，如果数字小于存储数据的字节数（=二进制数的位数），那么高位上就用0填补。
    - 例如，100111这个6位二进制数，用8位（=1字节）表示时为00100111，用16位（=2字节）表示时为0000000000100111.

对于用二进制数表示的信息，计算机不会区分它是数值、文字，还是某种图片的模式等，而是根据编写程序的各位对计算机发出的指示来进行信息的处理（运算）。
  - 例如00100111这样的二进制数，既可以视为纯粹的数值作加法运算，也可以视为”“文字而显示在显示器上；
    - 具体进行何种处理，取决于程序的编写方式。
  - 如果是把图片转换为二进制表达的话，CPU不知道这是图，但是显示程序会按照对应规则把它画出来。
   
## 位权

位权（Positional Weight），指的是在一个数中，某一位上的数字所代表的实际值，它由该位的位置决定。   

位权 = 基数 ^ 位数位置（从右往左，从0开始）
  - 基数：进制的“底”，比如十进制基数是10，二进制是2。
  - 位置：从右往左数，最右边第一位是第0位。

> 比如，十进制中的534，534 = 5×10² + 3×10¹ + 4×10⁰ = 500 + 30 + 4，这里的 10², 10¹, 10⁰ 就是各位的位权。
  这一点对于二进制也是一样的，二进制数00100111相当于十进制的39，我们也可以把它写成（0x128）+（0x64）+（1x32）+（0x16）+（0x8）+（1x4）+（1x2）+（1x1）=39。
  
位权的思考方式也同样适用于二进制数。即第1位是2的0次幂，第2位是2的1次幂，第3位是2的2次幂，......。

> 二进制中为什么要使用各数位的数值和位权相乘后”相加“这个处理
  - 因为在任何进制下的数字，本质上都是一个多项式展开式，十进制是这样的，这种思考方式在二进制数中也是通用的；
  - 这不是巧合，而是人类为了高效表示数字而人为规定的规则。

## 移位运算和乘除运算的关系

和十进制数一样，四则运算同样也可以使用在二进制数中，只要注意逢2进位即可。

二进制数所特有的运算，也是计算机所特有的运算，因此可以说是了解程序运行原理的关键。
1. 移位运算；
2. 乘除运算。

### 移位运算

移位运算指的是将二进制数值的各数位进行左右移位（shift = 移位）的运算。  

移位有左移（向高位方向）和右移（向低位方向）两种。  

在一次运算中，可以进行多个数位的移位操作。  

在 C 语言中，<<这个运算符表示左移，>>表示右移，运算符左侧是被移位的值，右侧表示要移位的位数；
  - 移位运算中左移后空出的低位用0填充，
  - 移位运算中，最高位或者最低位多出来的数字（称为溢出）会被直接舍弃，
  - 而用来填充右移后空出来的高位的数值，有0和1两种形式。

> 在二进制中，位权是从右往左、从 0 开始计算的！（整数部分是这样的
  从右往左，依次是0、1、2、3、4、......

#### 二进制表示负数的方法和右移的方法


二进制数中表示负数值时，一般会把最高位作为符号来使用，因此我们把这个最高位称为符号位。
  - 符号位是0时表示正数，符号位是1时表示负数。

计算机在做减法运算时，实际上内部是在做加法运算。  
  - A - B 在计算机中会被转换成 A + (-B)，而 -B 是通过求 B 的补码得到的。

旧版：  
为此在表示负数时就需要使用 “二进制的补数”，补数就是用正数来表示负数。  
获得补数的方法是，将二进制数的各数位的数值全部取反，然后再将结果加1。  
  -这里的加1是加在最低位上的。

>  00000001  
  +10000001  
  =
   10000010  
   
   二进制的加法是当两个1相加时，结果是0并产生一个进位1

第3版：  
2的补码是在二进制中用正数来表示负数的一种神奇的方法。
要得到2的补码，我们需要先将二进制数的各位数字反转，然后再将结果加1。  
例如，将-1用8位二进制数表示，就相当于求1（即00000001）的2 的补码。  
00000001的2的补码，就是将其各位数字中的0变成1，1变成0，然后将得到的结果加1，也就是11111111。  

---

二进制左移后就会变成原来的2倍、4倍、8倍......反之，二进制数右移后则会变成原来的1/2、1/4、1/8......  
因此移位运算可以代替乘法运算和除法运算。

## 逻辑右移和算数右移的区别

当二进制数的值表示图形模式而非数值时，移位后需要在最高位补0。类似于霓虹灯往右滚动的效果。这就称为逻辑右移。

将二进制数作为带符号的数值进行运算时，移位后要在最高位填充移位前符号位的值（0或1）。这就称为算术右移。

只有在右移时才必须区分逻辑位移和算数位移。  
  - 左移时，无论是图形模式（逻辑左移）还是相乘运算（算术左移），都只需在空出来的低位补0即可。

> 符号扩充：以8位二进制数为例，符号扩充就是指在保持值不变的前提下将其转换成16位和32位的二进制数。
    - 不管是正数还是用补数表示的负数，都只需用符号位的值（0或者1）填充高位即可。

## 掌握逻辑运算的窍门

将二进制数表示的信息作为四则运算的数值来处理就是算数；  
像图形模式那样，将数值处理为单纯的0和1的罗列就是逻辑。  

计算机能处理的运算，大体可分为算数运算和逻辑运算。  

  - 算数运算是指加减乘除四则运算；
  - 逻辑运算是指对二进制数各数字位的0和1分别进行处理的运算。包括
    1. 逻辑非（NOT运算）；
       - 指的是0变成1、1变成0的取反操作。
    2. 逻辑与（AND运算）；
       - 指的是“两个都是1”时，运算结果为1，其他情况下运算结果都为0的运算。
    3. 逻辑或（OR运算）；
       - 指的是“至少有一方是1”时，运算结果为1，其他情况下运算结果都是0的运算。
    4. 逻辑异或（XOR）运算。
       - 指的是排斥相同数值的运算，“两个数值不同”，也就是说，当“其中一方是1，另一方是0”时运算结果是1，其他情况下结果都是0。

以下表格总结了各逻辑运算的结果，这些表称为真值表。

逻辑非（NOT运算）的真值表
|A的值|NOT A的运算结果|
|---|---|
|0|1|
|1|0|

逻辑与（AND运算）的真值表
|A的值|B的值|A AND B的运算结果|
|---|---|---|
|0|0|0|
|0|1|0|
|1|0|0|
|1|1|1|

逻辑或（OR运算）的真值表
|A的值|B的值|A OR B的运算结果|
|---|---|---|
|0|0|0|
|0|1|1|
|1|0|1|
|1|1|1|

逻辑或（OR运算）的真值表
|A的值|B的值|A XOR B的运算结果|
|---|---|---|
|0|0|0|
|0|1|1|
|1|0|1|
|1|1|0|

掌握逻辑运算的敲门就是要摒弃用二进制数表示数值这一想法，大家不要把二进制数表示的值当作是数值，而应该把它看作是屠星或者开关时的ON/OFF（1是ON，0是OFF）。  
逻辑运算的运算对象不是数值，因此不会出现进位的情况。

# 小数运算

## 热身问答

1. 二进制数0.1，用十进制表示的话是0.5；
   - 二进制数的小数点后第一位的位权是2的负一次幂=0.5。
   
2. 用小数点后有3位的二进制数，能表示十进制数0.625吗 - 能
   - 十进制数0.625转换成二进制数是0.101。
   
3. 将小数分为符号、尾数、基数、指数4部分进行表现的形式称为浮点数（浮点数形式）；
   - 浮点数是指把小数用“符号尾数x基数的指数次幕”这种形式来表示。

4. 二进制数的基数是2；
   - 二进制数的基数是2,十进制数的基数是10。以此类推，XX 进制数的基数就是XX。

5. 通过把0作为数值范围的中间值，从而在不是用符号位情况下来表示负数的表示方法称为EXCESS系统表现；

6. 10101100.01010011这个二进制数，用十六进制数表示的话是AC.53。
   - 整数部分和小数部分一样，二进制数的4位，就相当于十六进制数的1位。

> 大家可能会认为“万能的计算实际是不会出现计算错误的。”。但实际上，仍然存在程序与逆行后无法得到正确数值的情况。  
  其中，小数运算就是一个典型的例子。
  例如，将0.1累加100次，得到的不会是10而是10.000002。
  
## 用二进制表示小数

由于计算机内部所有的信息都是以二进制数的形式来处理的，因此在这一点上，整数和小数并无差别。  
不过，使用二进制数来表示正数和小数的方法却有很大的不同。

二进制小数点后面部分的位权，从左到右从-1开始算，依次递减。  
这一规律不仅限于二进制数，在十进制数和十六进制数中也同样适用。  

## 计算机运算出错的原因

计算机之所以会出现运算错误，是因为“有一些十进制数的小数无法转换成二进制数”。  
例如，十进制数0.1就无法用二进制数正确表示，小数点后面即使有几百位也无法表示。

## 浮点数

像1011.0011这样带小数点的表现形式，完全是纸面上的二进制数表现形式，在计算机内部是无法使用的。  
很多编程语言中都提供了两种表示小数的数据类型，分别是双精度浮点数和单精度浮点数。
  - 双精度浮点数类型用64位、单精度浮点数用32位来表示全体小数；
  - 双精度浮点数和单精度浮点数能表示的正数和负数范围特别巨大，不过有些数值还是无法正确表示的。
  
浮点数是指用符号、位数、基数和指数这四部分来表示的小数。
  - 因为计算机内部使用的是二进制数，所以基数自然就是2。因此，实际的数据中往往不考虑基数，只用符号、尾数、指数这三部分即可表示浮点数。
  
浮点数的表现形式：
&plusmn;m x n<sup>e</sup>
- &plusmn;为符号
- m为尾数
- n为基数
- e为指数

浮点数的表现方式有很多种，最为普遍的是IEEE标准。  
双精度浮点数和单精度浮点数在表示同一个数值时使用的位数不同。此外双精度浮点数能够表示的数值范围要大于单精度浮点数。  

IEEE规定浮点数的内部构造：

1. 双精度浮点数（共64位）  
   符号部分（1位）+指数部分（11位）+尾数部分（52位）  

2. 单精度浮点数（共32位）  
   符号部分（1位）+指数部分（8位）+尾数部分（23位）  

符号部分是指使用一个数据位来表示数值的符号。  
  - 该数据位是1时表示负，为0时则表示“正或者0”，这和用二进制数来表示整数时的符号位是同样的。

尾数部分和指数部分并不只是单单存储着用正数表示的二进制数。  
  - 尾数部分用的是整数部分固定为1 的规格化（normal）表示法；
  - 指数部分则使用移码（excess）表示法。

#### 规格化（normal）表示法

尾数部分使用规格化表示法，可以将表现形式多样的浮点数统一为一种表现形式。  
例如，十进制数0.75就有很多种表现形式，虽然不同的表现形式都表示的同一个数值，但因为表现方法太多，计算机在处理时会比较麻烦。因此为了方便计算机处理，需要制定一个统一的规则。  
根据这个规则来表示小数的方式，就是规格化表示法。  

> 第二版中使用 "正则表达式" 来描述该表示法，含义为：**按照特定的规则来表示数据的形式**。本书成书时间较早（2007年），当时正则表达式还没有今天那么强烈的指代 "字符串格式" 的含义，而如今使用该词已经不再合适了。
> 现代一般这么使用正则：
> ```text
> 正则表达式：[+-]?\d*\.?\d+
> 匹配形如这样的字符串："0.75","-3.14",".5"
> 
> 正则表达式：\d{4}-\d{2}-\d{2}
> 匹配这样的字符串："2025-12-28","1999-01-01"
> ```
> 第三版中，使用规格化表示法，本段注释留作补充。

在二进制中，我们使用的是是整数部分固定为1的规格化表示法。
  - 具体来讲，就是将二进制数表示的小数左移或右移（这里是逻辑移位，因为符号位是独立的）数次后，整数部分的第1位变为1，第2位之后都变为0（即从第2 位起不存在有效数字）；
  - 第1位的1在实际的数据中不保存，由于第1位一定是1，因此省略该部分后就节省了一个数据位，从而也就可以表示更多的数据范围。
    - 即计算机存储的时候不存这个第1位的“1”，在内存中会把它默认加上，就可以多“赚”一位精度。
    - 单精度浮点数的尾数部分有23位，由于省略了整数部分的1，所以实际上可以表示24位的数值。
    - 双精度浮点数的规格化表示也是如此，只是使用的位数不同而已。
  
示例：
单精度浮点数尾数部分的规格化表示
  - 1011.0011 原始数值
  - 0001.0110011 右移使整数部分的第1位变成1
  - 0001.01100110000000000000000 确保小数点以后的长度为23位
  - 01100110000000000000000 仅保留小数点后面的部分，完成其规格化表示

#### 移码表示法

指数部分中使用移码表示法主要是为了表示负数时不是用符号位。  
指数部分有时需要表示“负××次幂”这样的负数，移码表示法就是将指数部分表示范围的中间值规定为0，从而可以在不使用符号位的情况下表示负数。   

例：  
指数部分为二进制数11111111（十进制数255）时，它在移码表示法中就代表128，因为255 - 127 = 128。  

## 如何避免计算机计算出错

不管是使用单精度浮点数还是双精度浮点数来处理小数，计算机都存在计算出错的可能性。  

以下是两种避免该问题的方法：  

1. 回避策略；
   - 即无视这些错误，根据程序目的的不同，有时一些微小的偏差并不会造成什么问题；
   - 一般来讲，在科学技术计算领域，计算机的计算结果只要能得到近似值就足够了，那些微笑的误差完全可以忽略掉。
   
2. 把小数转换成整数来计算。
   - 计算机在进行小数计算时可能会出错，但进行整数计算（只要不超过可处理的数值范围）时一定不会出现问题；
   - 比如本章开头讲过的将0.1相加100次这一计算，就可以转换为将0.1扩大10倍后再将1相加100次的计算，最后把结果除以10就可以了。
   
除此以外，BCD（Binary Coded Decimal）也是一种使用二进制表示十进制的方法。  
简单来讲，BCD就是用4位来表示0~9的1位数字的处理方法。  

在涉及财务计算等不允许出现误差的情况下，一定要将小数转换成整数或者采用BCD方法，以确保最终得到准确的数值。

## 二进制数和十六进制数

在以位为单位表示数据时，使用二进制数很方便，但如果位数太多，看起来就比较麻烦。  
因此，在实际程序中，也经常会用十六进制数来代替二进制数。  

在C语言程序中，只需在数值的开头加上0x（0和x）就可以表示十六进制数。  

用十六进制数来表示二进制小数时，小数点后的二进制数的4位也同样相当于十六进制数的1位。不够4位时用0填补二进制数的低位即可。  

# 熟练使用内存

## 热身问答

1. 有十个地址信号引脚的内存IC (集成电路）可以指定的地址范围用二进制数来表示的话时0000000000-1111111111（用十进制数来表示的话时0-1023）；  
   - 地址信号引脚是十个时表示2<sup>10</sup>=1024个地址。
   
2. 高级编程语言中的数据类型表示的是占据内存区域的大小和存储在该内存区域的数据类型；  
   - 例如， C 语言数据类型中的short类型，它表示的就是占据 2 字 节的内存区域，并且存储整数。

3. 在32位内存地址的环境中， 指针变量的长度是32位；
   - 指针变量存储的内容是内存地址。
   
4. 长度为1字节的数据类型的数组和内存的物理结构是相同的；
   - 内存在物理上是以1 字节为单位存储数据的。
   
5. 用LIFO方式进行数据读写的数据结构称为栈；
   - LIFO=Last In First Out。
   
6. 根据数据的大小向两侧分支的数据结构叫二叉查找树；
   - 二叉查找树是一种从节点分出两个分支的数据结构。
   
> 计算机是处理数据的机器，而程序负责规定处理步骤和数据结构。
  - 这里的数据结构是指数据在计算机中的组织、存储和管理方式；
    - 比如数组、栈；
  - 数据结构决定了数据怎么排列、数据之间有什么关系以及如何高效地访问、查找、修改这些数据。
  
## 内存的物理结构

从物理上看，内存的结构其实非常简单，但通过程序的设计，我们也可以让内存变身为各种不同的数据结构来使用。  
这绝不是什么稀罕的事情，而是很多程序中使用的一般方法。  

内存本质上是一种名为内存芯片的装置。  
内存芯片分为RAM（Random Access Memory，随机存取存储器）、ROM（Read Only Memory，只读存储器）等不同类型。  

内存芯片上有很多引脚，这些引脚负责连接电源，以及输入输出地址信号、数据信号和控制信号，通过指定地址，就可以对数据进行读写。  

> RD（read，读取的简写） WR（write，写入的简写）

一块有D0-D78根数据信号引脚、A0～A9共10根地址信号引脚的内存芯片。  
它一次可以输入输出的数据长度为8比特（=1字节），可以指定0000000000~1111111111这1024个地址。  
地址表示的是数据存储的位置，因此这块内存芯片能够存储1024个1字节的数据。由于1024=1K，所以这块内存芯片的容量是1KB。  
  - 内存的容量通常是以能存储多少字节来衡量的。

> 在计算机领域，人们习惯按照1024而不是1000进位，因为1024可以用2的整数次幂（210）表示。  
  通常，小写的“k”表示1000进位，大写的“K”表示1024进位。

要写入1字节数据到1KB内存芯片：

1. 接通电源（VCC=+5V，GND=0V）；
2. 通过地址信号A0～A9指定存储位置；
3. 将数据输入数据信号D0～D7；
4. 设置WR信号=1，完成写入。

要读取数据：

1. 通过地址信号A0～A9指定地址；
2. 设置RD信号=1，指定地址中存储的数据将通过D0～D7输出。

WR和RD是控制信号，均为0时芯片不操作。

## 内存的逻辑结构

使用楼来类比内存的话，那在这栋楼中，每一层都可以存储1 字节的数据，楼层编号就是地址。  
尽管内存的本质是内存芯片，但从程序员的角度来看，还是将它想象成一幢每层都能存储数据的大楼比较好，并不需要关心内存芯片的电源和控制信号。  

内存有一个物理上的内存所不存在的概念，那就是数据类型。  
在编程语言中，数据类型代表要存储哪一类数据，以及该数据在内存中占多少空间（大楼的层数）。  
从物理上说，内存是以1字节为单位读写数据的，但在程序中，我们通过指定类型（变量的数据类型），就可以以特定的字节数为单位来读写数据。  

通过使用变量，我们就可以在不指定物理地址的情况下在程序中完成内存的读写。  
Windows 等操作系统会在程序运行时为变量分配物理内存地址。  

同样的数，赋值给不同数据类型的变量之后占用的内存空间大小也不同。  

> 对于占用多个字节的数据，将数据的低位存放在内存低地址的方式称为“小端序”（little endian）。  
  与之相对，将数据的高位存放在内存低地址的方式称为“大端序”（big endian）

> 一般来说，在C语言中，数据类型中，8字节（ = 64 比特）的double型是最大的。

## 指针

理解指针的关键也在于数据类型这一概念。  

指针是一种变量，它不存储数据本身的值，而是存储数据所在的内存地址。使用指针可以读写任意地址的数据。  

在我们前面展示的假想内存芯片中，地址信号用10比特来表示。  
而在大家一般所使用的PC上运行的程序大多是使用32比特（4字节）来表示内存地址的，这时指针变量的长度就是32位。  

指针本质上是一个内存地址的值，它被声明为某种数据类型，并不影响地址本身的大小，而是决定了通过这个读写时，一次操作多少字节的数据。  

## 数组之于内存

数组是将相同数据类型（长度）的多个数据连续排列在内存中的一个元素序列。  
其中每个数据就是数组的元素，元素通过顺序编号来进行区分，这个编号称为下标。  
通过下标可以读写相应的内存空间，将下标转换成实际内存地址的操作是由编译器自动完成的。

C 语言中数组的下标是从0 开始的。
  - char g[100]; 表示可以使用的元素为g[0]～g[99]，共100个。

声明数组时所指定的类型也代表了对内存读写一次的长度。  
char型数组以1字节为单位，short型数组以2字节为单位，long型数组以4字节为单位对内存进行读写。  

数组之所以是使用内存的基础，是因为它反映的就是内存的物理结构本身。特别是1字节型的数组，和内存的物理结构完全一致。  
但是，如果只能以1字节为单位来进行读写的话，程序编写起来会非常麻烦，因此才提供了通过指定数据类型来声明数组的功能。  

> short h[100]的意思是在内存中申请 100 个连续的short类型变量，每个short占 2个字节（bytes），所以总共占用 200个字节 的空间。

## 栈与队列，以及环形缓冲区

栈和队列都是无须指定地址和下标就可以对数组元素进行读写的结构。  

在需要临时保存计算中间结果或计算机外部设备的输入输出数据时，经常会以这些方式来使用内存。  
为了保存临时数据，每次都指定地址和下标非常麻烦，因此人们才设计了这些方式加以改善。  

栈和队列的区别在于数据的出入顺序。  
在对内存进行读写时，
  - 栈采用的是LIFO（Last In First Out，后进先出）方式；
  - 而队列采用的是FIFO（First In First Out，先进先出）方式。
事先在内存中预留栈和队列所需要的空间，并确定数据的读写顺序，就不需要指定地址和下标了。  

要在程序中实现栈和队列，需要先声明一个包含若干元素的数组用来存放数据，然后编写用于读写元素的函数。  
当然，这些函数会在内部对下标进行管理，以便读写数组，使用了这些函数，我们人本身就不需要考虑数组和下标了。  

队列通常会以环形缓冲区（ring buffer）的形式使用。

假设我们用一个包含6个元素的数组来实现一个队列。
1. 数据会按顺序从数组开头存放进来，并按照存放的顺序取出。
2. 当数据存放到数组的末尾时，下一个数据就会回到数组开头进行存放（此时数组开头原本存放的数据已被取出，因此这个位置是空的）。
4. 通过这样的方式，数组的末尾和开头就连接在了一起，从而实现了一种可以循环存放和取出数据的结构。

## 在链表中添加和删除元素

链表和二叉查找树都是不按下标顺序对数组进行读写操作的数据结构。  
  - 使用链表可以高效地向数组中添加和删除数据（元素）。
  - 使用二叉查找树可以高效查找数组中存放的数据。

链表的实现方式是对于数组中的每个元素，不仅保存它的值，还要额外保存其下一个元素的下标。  
也就是说，数据的值和下一个元素的下标合在一起形成了数组的一个元素。  
这样，数组的元素就像项链一样被串了起来，从而形成链表。  
  - 链表的末尾元素后面没有其他元素了，因此下一个元素的下标可以设为一个不存在的值

链表通过修改“下一个元素”的下标信息来实现数据的删除与插入。  
删除时，只需将前一个元素指向被删元素的后续元素，使其在逻辑上脱离链表结构；  
插入时，可复用空闲位置，通过调整前后元素的指针关系，使新元素在逻辑顺序上处于目标位置。  
物理存储位置无需连续，逻辑顺序由指针决定。

## 用二叉查找树高效地查找数据

二叉查找树在链表的基础上做进一步的扩展，当向数组中添加元素时，根据其大小关系向左右两个方向分支。  

实现二叉树的方法：让数组中的每个元素除了保存其本身的值，再额外保存两个下标就可以了。  

二叉查找树是链表结构的扩展，自然也可以高效地添加和删除元素。  

二叉查找树的方便之处在于它可以高效地查找数据。
  - 如果使用一般的数组，我们必须从头开始按照下标顺序逐个访问元素才能找到目标数据。
  - 而在使用二叉查找树的情况下，如果目标数据比当前访问的数据小就往左侧找，比当前访问的数据大就往右侧找，由此可以快速找到目标数据。

# 内存与磁盘

## 热身问答

1. 存储程序（stored program）方式是将程序存放在存储器中并依次执行的方式。
   - 现在的计算机基本上采用的是存储程序方式。
   
2. 使用内存来提高磁盘访问速度的机制叫磁盘缓存。
   - 磁盘缓存指将从磁盘中读取的数据暂时保存在内存中，当需要再次读取相同的数据时，就可以不访问磁盘，而是直接从内存中快速读取。

3. 将磁盘的一部分模拟成内存来使用的机制叫虚拟内存（virtual memory）。
   - 虚拟内存可以让内存容量小的计算机运行大型程序。
   
4. 在Windows中，包含函数和数据，在程序运行时进行动态链接的文件叫DLL（DLL文件）。
   - DLL是Dynamic Link Library（动态链接库）的缩写。
   
5. 将函数静态链接到EXE文件中的过程叫静态链接（static link）。
   - 更白话一点解释：静态链接就是在做 EXE的时候，把需要用到的函数“打包”进程序本身，程序运行时直接用自己带的函数代码。
   
6. 在PC中，硬盘的1个扇区大小一般为512字节。
   - 扇区（sector）是磁盘的物理存储单位。
   - “硬盘”是“磁盘”的一种。
     - 磁盘是利用磁性材料存储数据的圆形盘片，是一种存储介质的统称；
     - 硬盘特指计算机中使用的固定在主机内的大容量磁性存储设备，全称是“硬盘驱动器”。

> 在计算机系统中，速度快、容量小的内存和速度慢、容量大的磁盘取长补短，相互配合完成工作。

## 程序加载到内存后才能运行

计算机中的存储器包括内存和磁盘。
存储在磁盘中的程序需要先加载到内存才能运行，不能在磁盘上直接运行。
这是因为CPU在对程序内容进行解释和运行时，是通过其内部的程序计数器指定内存地址来读取程序的。  

即便CPU能够直接读取并运行磁盘上的程序，由于磁盘读取速度慢，所以程序的运行速度也会很慢。
存储在磁盘中的程序需要先加载到内存后才能运行，这是我们在思考内存与磁盘的关系时必须明确的大前提。

## 磁盘缓存

磁盘缓存是一块内存空间，用于临时存放从磁盘读取出来的数据。  
下次需要读取相同的数据时，就不需要实际访问磁盘，而是从磁盘缓存中读取数据就可以了。  
有了磁盘缓存，就能够提高磁盘数据的访问速度了。  

将低速设备中的数据保存在高速设备中，当需要相同数据时直接从高速设备中读取，这样的设计就叫作缓存。  

## 将磁盘当成内存使用的虚拟内存

虚拟内存是将磁盘的一部分模拟成内存来使用的机制。  
有了虚拟内存，我们就可以在内存不足的状态下运行程序。  

但是，CPU只能运行已经加载到内存中的程序。  
因此，即使通过虚拟内存用磁盘来代替内存使用，实际运行的程序部分在运行时也必须存放在内存中。  
于是，为了实现虚拟内存，就需要在运行程序的过程中，对实际内存（物理内存）和磁盘上的虚拟内存中的部分内容进行置换。  

虚拟内存的实现方式分为分页式和分段式。
  - 分页式：在这种方式中，要运行的程序无论结构如何，都会被划分成一定大小的“页面”，并以页面为单位在内存和磁盘之间进行置换。
    - 将磁盘中的内容读入内存称为页面换入（page in）；
    - 将内存中的内容写入磁盘称为页面换出（page out）。
  - 分段式：操作系统会以处理集合或数据集合为单位把要运行的程序划分成段，并以段为单位在内存和磁盘之间进行置换。

## 将内存当成磁盘使用的固态硬盘

固态硬盘是将一种可读写的且断开电源后内容不会丢失的闪存（flash memory）作为硬盘来使用的产品。  
固态硬盘的本质是内存，但从用户的角度来看它就是一块硬盘。  
  - USB 驱动器、SD 卡等也是用闪存来存储的设备。

## 节约内存的编程技巧

> GUI（Graphical User Interface，图形用户界面）
  像Windows 这样通过窗口、菜单、图标等视觉元素来进行操作的方式称为GUI。
  Windows 的前身MS-DOS 则是通过键盘输入命令来进行操作的，这样的方式称为CUI（Character User Interface，字符用户界面）。

要彻底解决内存不足的问题，只能增加内存容量，或是缩减应用程序的大小。  
以下是两个缩减应用程序大小的编程技巧。  
1. 通过DLL文件共享函数；
2. 通过_stdcall 调用缩减程序大小。

### 通过DLL 文件共享函数

所谓DLL文件，顾名思义，就是在程序运行时进行动态链接的库（函数和数据的集合）。  
但是多个应用程序可以共享同一个DLL 文件。这就可以达到节约内存的效果。  

假设有一个函数MyFunc() 被应用程序A和B同时使用。  
如果采用静态链接，把MyFunc()分别嵌入到两个可执行文件中，那么当A和B同时运行时，内存中会存在两份完全相同的MyFunc()，造成内存空间的浪费、降低利用效率。  
如果不把MyFunc() 嵌入到各个EXE中，而是把它放在一个独立的DLL文件里，那么当多个程序同时运行时，它们可以共享同一个DLL，内存中只需要一份MyFunc()，从而提高了内存利用效率。  

> 此外，DLL 文件还有另一个优点，那就是在版本升级时，有时不需要更换EXE 文件，只要更换DLL 文件就可以了。

### 通过_stdcall 调用缩减程序大小

#### 1. 默认调用约定（cdecl）

- 函数参数由**调用方**压入栈中  
- 函数返回后，由**调用方**负责执行栈清理操作  
- 栈清理通常通过 `addl $8, %esp` 等指令完成

#### 2. `_stdcall` 调用约定

- 函数参数仍由**调用方**压入栈中  
- 函数返回时，由**被调用函数**负责完成栈清理  
- 调用方无需再执行清栈指令  
- 可减少重复的栈清理代码，缩小程序整体体积

> 调用方：调用函数的那段代码
  被调用方：函数本身
  默认情况：调用方负责清理参数
  _stdcall：函数自己在返回时清理参数

## 磁盘的物理结构

磁盘的表面在物理上被划分成若干区域，划分方法分为按固定长度划分的扇区方式，以及按可变长度划分的可变长方式。  

一般PC 所使用的硬盘是采用扇区方式来进行划分的。
  - 在扇区方式中，磁盘表面被划分成若干同心圆状的磁道，每条磁道再被划分成若干固定长度（存储的数据长度相等）的扇区.

### 扇区（Sector）
- 磁盘在物理上可读写的最小单位。  
- Windows系统中，一个扇区通常为512字节。

### 簇（Cluster）
- Windows在逻辑（软件）上读写磁盘的单位。  
- 一个簇由若干个扇区组成，即簇=扇区的整数倍。  
- 簇的实际长度根据硬盘容量确定。

- 规律：磁盘容量越大，簇的长度也越大。   

---

由于磁盘只能按簇来管理文件，一个簇只能属于一个文件，不能同时存放多个文件的数据。  
所以即使文件很小，也必须独占一个簇，文件在磁盘上占用的空间只能是若干个完整簇的大小。

在以簇为单位读写磁盘的情况下，一个簇中没有占满的空间就只能被闲置。
- 簇未占满的空间会闲置，导致小文件存在“空间浪费”。  
- 簇越大，浪费越多；簇越小，空间利用率越高。

如果将簇的长度变小，就会增加磁盘的访问次数，造成文件读写速度下降。
- 簇越小，同一个文件会被分割成更多簇。  
- 访问磁盘时，每个簇都需要单独定位和读取。  
- 簇数量多 → 访问次数多 → 读写速度下降。

由于磁盘需要额外的空间记录扇区的划分方式，所以如果簇的长度太小，磁盘整体的存储容量就会减少。
- 磁盘需要额外空间记录簇的使用情况。  
- 簇越小，簇数量越多，管理信息占用空间越大 → 可用存储容量减少。

扇区和簇的大小需要在处理速度和存储容量之间寻找平衡。
- 簇小：空间利用率高，但读写次数多 → 速度慢，管理信息占用空间多。  
- 簇大：读写速度快，管理信息少，但小文件浪费空间多。  
- 结论：簇大小需要在**处理速度**和**存储容量**之间寻找平衡。















































































