# CPU

## 热身问答

1. 程序是指示计算机每一步行动的一组指令；
2. 程序是由指令和数据构成的；
3. 机器语言是 CPU 可以直接识别并使用的语言；
     - 使用 C、Java 等语言编写的程序最后都会转化成机器语言。
4. 正在运行的程序存储在内存；
     - 硬盘和磁盘等媒介上保存的程序被复制到内存后才能运行。
5. 内存地址是内存中用来表示命令和数据存储位置的数值；
     - 地址是由整数值表示。
        - 计算机的内存（RAM）是由许多存储单元组成的，每个存储单元都有一个唯一的编号，这个编号就叫 内存地址。
6. 计算机的构成元件中， 负责程序的解释和运行的是CPU。

## CPU 的内部结构解析

CPU 和内存是由许多晶体管组成的电子部件， 通常称为 IC (lntegrated Circuit, 集成电路）构成的。  

从功能方面来看，CPU的内部由四个部分构成， 各部分之间由电流信号相互连通。
1. 寄存器；
   - 寄存器可用来暂存指令、数据等处理对象， 可以将其看作是内存的一种。
2. 控制器；
   - 控制器负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。
3. 运算器；
   - 运算器负责运算从内存读入寄存器的数据。
4. 时钟。
   - 时钟负责发出 CPU 开始计时的时钟信号。
   
> 有些计算机的时钟位于CPU的外部
   - 说明计算机系统中的“时钟信号”（Clock Signal）不是由CPU内部产生的，而是由主板或其他外部电路提供给CPU的。

> 程序运行流程示例：
  1. 程序员用C语言等高级语言编写程序；
  2. 将程序编译后转换成机器语言的 EXE 文件；
  3. 程序运行时，在内存中生成 EXE 文件的副本；
     - 因为 CPU 只能直接从内存（RAM）中读取和执行指令，而不能直接从硬盘上运行程序。
  4. CPU 解释并执行程序内容。

> 通常所说的内存指的是计算机的主存储器（main memory），简称主存。
  主存通过控制芯片等与 CPU 相连，主要负责存储指令和数据。
  需要注意的是，主存中存储的指令和数据会随着计算机的关机而自动清除。
  
## CPU 是寄存器的集合体

CPU 的构成部分中，程序员只需要了解寄存器即可，因为程序是把寄存器作为对象来描述的，其余部分都不用太过关注。  

> 通常我们将汇编语言编写的程序转化成机器语言的过程称为汇编；反之，机器语言程序转化成汇编语言程序的过程则称为反汇编。

通过阅读汇编语言编写的代码，能够了解转化成机器语言的程序的运行情况。机器语言级别的程序时通过寄存器来处理（即存储）的。
  - 也就是说，在程序员看来，“CPU 是寄存器的集合体”。

对于程序员来说，CPU 时具有各种功能的寄存器的集合体。
  - 其中，程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其他的寄存器一般由多个。
  - 程序计数器和标志寄存器比较特殊。
  
|种类|功能|
|---|---|
|累加寄存器（accumulator register）|存储执行运算的数据和运算后的数据|
|标志寄存器（flag register）|存储运算处理后的 CPU 状态|
|程序计数器（program counter）|存储下一条指令所在内存的地址|
|基址寄存器（base register）|存储数据内存的起始地址|
|变址寄存器（index register）|存储基址寄存器的相对地址|
|通用寄存器（general purpose register）|存储任意数据|
|指令寄存器（instruction register）|存储指令。CPU 内部使用，程序员无法通过程序对该寄存器进行读写操作|
|栈寄存器（stack register）|存储栈区域的起始地址|

## CPU 解释并执行程序的过程（个人理解

1. 由操作系统在加载程序时，根据“入口点”设置程序计数器里的指令地址；
2. 控制器根据 PC 提供的地址，向内存发起读取指令；
3. 内存获取读取指令后向控制器返回对应地址中存储的指令内容；
4. 控制器进行译码分析指令类型并执行，即指挥 ALU/寄存器/内存完成操作；
5. 更新 PC 中的值；
6. 回到第二步，继续下一条指令。

## 条件分支和循环机制

程序的流程分为顺序执行、条件分支和循环三种。
  - 顺序执行是指按照地址内容的顺序执行指令；
    - 顺序执行中，每执行一个指令程序计数器的值就会自动递增以指向内存中下一条连续的指令。
  - 条件分支是指根据条件执行任意地址的指令；
  - 循环是指重复执行同一地址的指令。

> 条件分支和循环中使用的跳转指令，会参照当前执行的运算结果来判断是否跳转。
  - 标志寄存器的数值会根据运算结果自动设定，条件分支在跳转指令前会进行比较运算；
    - 至于是否执行跳转指令，则由 CPU 在参考标志寄存器的数值后进行判断。
      
## 函数的调用机制

1. 函数调用时使用call指令，而不是跳转指令；
2. call指令会把调用函数后要执行的指令地址存储在程序的栈区域内；
3. 然后将函数的入口地址设定到程序计数器；
4. 函数处理完毕后，再通过函数的出口来执行return指令；
    - return 指令的功能是把保存在栈中的地址设定到程序计数器中。

## 通过地址和索引实现数组

通过基址寄存器和变址寄存器可以对主内存上特定的内存区域进行划分，从而实现类似于数组的操作。

例如查看10000000地址~1000FFFF地址时，
   - 可以将10000000存入基址寄存器，并使变址寄存器的值在00000000~0000FFFF变化；
   - CPU 则会把基址寄存器+变址寄存器的值解释为实际查看的内存地址。

> 变址寄存器的值就相当于高级编程语言程序中数组的索引功能。

> 机器语言指令的主要类型和功能

|类型|功能|
|---|---|
|数据转送指令|寄存器和内存、内存和内存、寄存器和外围设备之间的数据读取操作|
|运算指令|用累加寄存器执行算术运算、逻辑运算、比较运算和移位运算|
|跳转指令|实现条件分支、循环、强制跳转等|
|call/return指令|函数的调用/返回调用前的地址|

# 数据是用二进制数表示的

## 热身问答

8位=1字节，32位就是4字节；
  - “位”是数据最小单位（0 或 1），“字节”是计算机处理数据的基本单位，1 字节 = 8 个位。
反转部分图形模式时， 使用的是什么逻辑运算？
  - XOR 运算只反转与1相对应的位。NOT运算时反转所有的位。

## 用二进制数表示计算机信息的原因

计算机内部是由 IC 这种电子部件构成的，IC 上的所有引脚都只有直流电压 0V 或 5V 两个状态。也就是说 IC 的一个引脚，只能表示两个状态。  
IC 的这个特性，决定了计算机的信息数据只能用二进制数来处理。  

> 二进制数的位数一般是8位、16位、32位......也就是8的倍数，这是因为计算机所处理的信息的基本单位是8位二进制数。  

内存和磁盘都使用字节单位来存储和读写数据，使用位单位则无法读写数据，因此字节是信息的基本单位。  
  - 用字节单位处理数据时，如果数字小于存储数据的字节数（=二进制数的位数），那么高位上就用0填补。
    - 例如，100111这个6位二进制数，用8位（=1字节）表示时为00100111，用16位（=2字节）表示时为0000000000100111.

对于用二进制数表示的信息，计算机不会区分它是数值、文字，还是某种图片的模式等，而是根据编写程序的各位对计算机发出的指示来进行信息的处理（运算）。
  - 例如00100111这样的二进制数，既可以视为纯粹的数值作加法运算，也可以视为”“文字而显示在显示器上；
    - 具体进行何种处理，取决于程序的编写方式。
    
## 位权

位权（Positional Weight），指的是在一个数中，某一位上的数字所代表的实际值，它由该位的位置决定。   

位权 = 基数 ^ 位数位置（从右往左，从0开始）
  - 基数：进制的“底”，比如十进制基数是10，二进制是2。
  - 位置：从右往左数，最右边第一位是第0位。

> 比如，十进制中的534，534 = 5×10² + 3×10¹ + 4×10⁰ = 500 + 30 + 4，这里的 10², 10¹, 10⁰ 就是各位的位权。

位权的思考方式也同样适用于二进制数。即第1位是2的0次幂，第2位是2的1次幂，第3位是2的2次幂，......。

> 二进制中为什么要使用各数位的数值和位权相乘后”相加“这个处理
  - 因为在任何进制下的数字，本质上都是一个多项式展开式，十进制是这样的，这种思考方式在二进制数中也是通用的；
  - 这不是巧合，而是人类为了高效表示数字而人为规定的规则。

## 移位运算和乘除运算的关系

和十进制数一样，四则运算同样也可以使用在二进制数中，只要注意逢2进位即可。

二进制数所特有的运算，也是计算机所特有的运算，因此可以说是了解程序运行原理的关键。
1. 移位运算；
2. 乘除运算。

### 移位运算

移位运算指的是将二进制数值的各数位进行左右移位（shift = 移位）的运算。  

移位有左移（向高位方向）和右移（向低位方向）两种。  

在一次运算中，可以进行多个数位的移位操作。  

在 C 语言中，<<这个运算符表示左移，>>表示右移，运算符左侧是被移位的值，右侧表示要移位的位数；
  - 移位运送中左移后空出的低位用0填充，
  - 而用来填充右移后空出来的高位的数值，有0和1两种形式。

> 在二进制中，位权是从右往左、从 0 开始计算的！（整数部分是这样的
  从右往左，依次是0、1、2、3、4、......

#### 二进制表示负数的方法和右移的方法

二进制数中表示负数值时，一般会把最高位作为符号来使用，因此我们把这个最高位称为符号位。
  - 符号位是0时表示正数，符号位是1时表示负数。

计算机在做减法运算时，实际上内部是在做加法运算。  
  - A - B 在计算机中会被转换成 A + (-B)，而 -B 是通过求 B 的补码得到的。

为此在表示负数时就需要使用 “二进制的补数”，补数就是用正数来表示负数。  
获得补数的方法是，将二进制数的各数位的数值全部取反，然后再将结果加1。  
  -这里的加1是加在最低位上的。

>  00000001  
  +10000001
  ——————————
   10000010
   
   二进制的加法是当两个1相加时，结果是0并产生一个进位1
  
---

二进制左移后就会变成原来的2倍、4倍、8倍......反之，二进制数右移后则会变成原来的1/2、1/4、1/8......  
因此移位运算可以代替乘法运算和除法运算。

## 逻辑右移和算数右移的区别

当二进制数的值表示图形模式而非数值时，移位后需要在最高位补0。类似于霓虹灯往右滚动的效果。这就称为逻辑右移。

将二进制数作为带符号的数值进行运算时，移位后要在最高位填充移位前符号位的值（0或1）。这就称为算术右移。

只有在右移时才必须区分逻辑位移和算数位移。  
  - 左移时，无论是图形模式（逻辑左移）还是相乘运算（算术左移），都只需在空出来的低位补0即可。

> 符号扩充：以8位二进制数为例，符号扩充就是指在保持值不变的前提下将其转换成16位和32位的二进制数。
    - 不管是正数还是用补数表示的负数，都只需用符号位的值（0或者1）填充高位即可。

## 掌握逻辑运算的窍门

将二进制数表示的信息作为四则运算的数值来处理就是算数；  
像图形模式那样，将数值处理为单纯的0和1的罗列就是逻辑。  

计算机能处理的运算，大体可分为算数运算和逻辑运算。  

  - 算数运算是指加减乘除四则运算；
  - 逻辑运算是指对二进制数各数字位的0和1分别进行处理的运算。包括
    1. 逻辑非（NOT运算）；
       - 指的是0变成1、1变成0的取反操作。
    2. 逻辑与（AND运算）；
       - 指的是“两个都是1”时，运算结果为1，其他情况下运算结果都为0的运算。
    3. 逻辑或（OR运算）；
       - 指的是“至少有一方是1”时，运算结果为1，其他情况下运算结果都是0的运算。
    4. 逻辑异或（XOR）运算。
       - 指的是排斥相同数值的运算，“两个数值不同”，也就是说，当“其中一方是1，另一方是0”时运算结果是1，其他情况下结果都是0。

以下表格总结了各逻辑运算的结果，这些表称为真值表。

逻辑非（NOT运算）的真值表
|A的值|NOT A的运算结果|
|---|---|
|0|1|
|1|0|

逻辑与（AND运算）的真值表
|A的值|B的值|A AND B的运算结果|
|---|---|---|
|0|0|0|
|0|1|0|
|1|0|0|
|1|1|1|

逻辑或（OR运算）的真值表
|A的值|B的值|A OR B的运算结果|
|---|---|---|
|0|0|0|
|0|1|1|
|1|0|1|
|1|1|1|

逻辑或（OR运算）的真值表
|A的值|B的值|A XOR B的运算结果|
|---|---|---|
|0|0|0|
|0|1|1|
|1|0|1|
|1|1|0|

掌握逻辑运算的敲门就是要摒弃用二进制数表示数值这一想法，大家不要把二进制数表示的值当作是数值，而应该把它看作是屠星或者开关时的ON/OFF（1是ON，0是OFF）。  
逻辑运算的运算对象不是数值，因此不会出现进位的情况。

# 小数运算

## 热身问答

1. 二进制数0.1，用十进制表示的话是0.5；
   - 二进制数的小数点后第一位的位权是2的负一次幂=0.5。
   
2. 用小数点后有3位的二进制数，能表示十进制数0.625吗 - 能
   - 十进制数0.625转换成二进制数是0.101。
   
3. 将小数分为符号、尾数、基数、指数4部分进行表现的形式称为浮点数（浮点数形式）；
   - 浮点数是指把小数用“符号尾数x基数的指数次幕”这种形式来表示。

4. 二进制数的基数是2；
   - 二进制数的基数是2,十进制数的基数是10。以此类推，XX 进制数的基数就是XX。

5. 通过把0作为数值范围的中间值，从而在不是用符号位情况下来表示负数的表示方法称为EXCESS系统表现；

6. 10101100.01010011这个二进制数，用十六进制数表示的话是AC.53。
   - 整数部分和小数部分一样，二进制数的4位，就相当于十六进制数的1位。

> 大家可能会认为“万能的计算实际是不会出现计算错误的。”。但实际上，仍然存在程序与逆行后无法得到正确数值的情况。  
  其中，小数运算就是一个典型的例子。
  例如，将0.1累加100次，得到的不会是10而是10.000002。
  
## 用二进制表示小数

由于计算机内部所有的信息都是以二进制数的形式来处理的，因此在这一点上，整数和小数并无差别。  
不过，使用二进制数来表示正数和小数的方法却有很大的不同。

二进制小数点后面部分的位权，从左到右从-1开始算，依次递减。  
这一规律不仅限于二进制数，在十进制数和十六进制数中也同样适用。  

## 计算机运算出错的原因

计算机之所以会出现运算错误，是因为“有一些十进制数的小数无法转换成二进制数”。  
例如，十进制数0.1就无法用二进制数正确表示，小数点后面即使有几百位也无法表示。

## 浮点数

像1011.0011这样带小数点的表现形式，完全是纸面上的二进制数表现形式，在计算机内部是无法使用的。  
很多编程语言中都提供了两种表示小数的数据类型，分别是双精度浮点数和单精度浮点数。
  - 双精度浮点数类型用64位、单精度浮点数用32位来表示全体小数；
  - 双精度浮点数和单精度浮点数能表示的正数和负数范围特别巨大，不过有些数值还是无法正确表示的。
  
浮点数是指用符号、位数、基数和指数这四部分来表示的小数。
  - 因为计算机内部使用的是二进制数，所以基数自然就是2。因此，实际的数据中往往不考虑基数，只用符号、尾数、指数这三部分即可表示浮点数。
  
浮点数的表现形式：
plus-minusm x n<sup>e</sup>
- plus-minus为符号
- m为尾数
- n为基数
- e为指数

浮点数的表现方式有很多种，最为普遍的是IEEE标准。  
双精度浮点数和单精度浮点数在表示同一个数值时使用的位数不同。此外双精度浮点数能够表示的数值范围要大于单精度浮点数。  

IEEE规定浮点数的内部构造：

1. 双精度浮点数（共64位）  
   符号部分（1位）+指数部分（11位）+尾数部分（52位）  

2. 单精度浮点数（共32位）  
   符号部分（1位）+指数部分（8位）+尾数部分（23位）  

符号部分是指使用一个数据位来表示数值的符号。  
  - 该数据位是1时表示负，为0时则表示“正或者0”，这和用二进制数来表示整数时的符号位是同样的。

尾数部分和指数部分并不只是单单存储着用正数表示的二进制数。  
  - 尾数部分用的是“将小数点前面的值固定为1的正则表达式”；
  - 指数部分用的则是“EXCESS系统表现”。

#### 正则表达式

尾数部分使用正则表达式，可以将表现形式多样的浮点数统一为一种表现形式。  
例如，十进制数0.75就有很多种表现形式，虽然不同的表现形式都表示的同一个数值，但因为表现方法太多，计算机在处理时会比较麻烦。因此为了方便计算机处理，需要制定一个统一的规则。  
根据这个规则来表示小数的方式，就是正则表达式。  

在二进制中，我们使用的是“将小数点前面的值固定为1的正则表达式”。
  - 具体来讲，就是将二进制数表示的小数左移或右移（这里是逻辑移位，因为符号位是独立的）数次后，整数部分的第1位变为1，第2位之后都变为0（这样是为了消除第2位以上的数位）
  - 第1位的1在实际的数据中不保存，由于第1位必须是1，因此省略该部分后就节省了一个数据位，从而也就可以表示更多的数据范围。
    - 即计算机存储的时候不存这个第1位的“1”，在内存中会把它默认加上，就可以多“赚”一位精度。
   
#### EXCESS系统

指数部分中使用EXCESS系统主要是为了表示负数时不是用符号位。  
EXCESS系统表现是指，通过将指数部分表示范围的中间值设为0，使得负数不需要用符号来表示。  

## 如何避免计算机计算出错

不管是使用单精度浮点数还是双精度浮点数来处理小数，计算机都存在计算出错的可能性。  

以下是两种避免该问题的方法：  

1. 回避策略；
   - 即无视这些错误，根据程序目的的不同，有时一些微小的偏差并不会造成什么问题；
   - 一般来讲，在科学技术计算领域，计算机的计算结果只要能得到近似值就足够了，那些微笑的误差完全可以忽略掉。
   
2. 把小数转换成整数来计算。
   - 计算机在进行小数计算时可能会出错，但进行整数计算（只要不超过可处理的数值范围）时一定不会出现问题；
   - 比如本章开头讲过的将0.1相加100次这一计算，就可以转换为将0.1扩大10倍后再将1相加100次的计算，最后把结果除以10就可以了。
   
除此以外，BCD（Binary Coded Decimal）也是一种使用二进制表示十进制的方法。  
简单来讲，BCD就是用4位来表示0~9的1位数字的处理方法。  

在涉及财务计算等不允许出现误差的情况下，一定要将小数转换成整数或者采用BCD方法，以确保最终得到准确的数值。

## 二进制数和十六进制数

在以位为单位表示数据时，使用二进制数很方便，但如果位数太多，看起来就比较麻烦。  
因此，在实际程序中，也经常会用十六进制数来代替二进制数。  

在C语言程序中，只需在数值的开头加上0x（0和x）就可以表示十六进制数。  

用十六进制数来表示二进制小数时，小数点后的二进制数的4位也同样相当于十六进制数的1位。不够4位时用0填补二进制数的低位即可。  

# 熟练使用内存

## 热身问答

1. 有十个地址信号引脚的内存IC (集成电路）可以指定的地址范围用二进制数来表示的话时0000000000-1111111111（用十进制数来表示的话时0-1023）；  
   - 地址信号引脚是十个时表示2<sup>10</sup>=1024个地址。
   
2. 高级编程语言中的数据类型表示的是占据内存区域的大小和存储在该内存区域的数据类型；  
   - 例如， C 语言数据类型中的 short类型，它表示的就是占据 2 字 节的内存区域，并且存储整数。

3. 在32位内存地址的环境中， 指针变量的长度是32位；
   - 指针指的是用于存储内存地址的变量。
4. 与物理内存有着相同构造的数组的数据类型长度是多少？
5. 用LIFO方式进行数据读写的数据结构称为什么？
6. 根据数据的大小链表分叉成两个方向的数据结构称为什么？



































































































































































